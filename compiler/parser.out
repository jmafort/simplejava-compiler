Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    WHITE_SPACE

Grammar

Rule 0     S' -> program
Rule 1     program -> declaration declarations
Rule 2     declarations -> declaration declarations
Rule 3     declarations -> empty
Rule 4     declaration -> struct ID inheritance LCURLYBRACE item_decls RCURLYBRACE
Rule 5     struct -> instance CLASS
Rule 6     struct -> INTERFACE
Rule 7     instance -> ABSTRACT
Rule 8     instance -> CONCRETE
Rule 9     inheritance -> EXTENDS ID
Rule 10    inheritance -> IMPLEMENTS ID
Rule 11    inheritance -> empty
Rule 12    item_decls -> visibility scope final item_decl SEMICOLON item_decls
Rule 13    item_decls -> empty
Rule 14    visibility -> PUBLIC
Rule 15    visibility -> PROTECTED
Rule 16    visibility -> PRIVATE
Rule 17    scope -> STATIC
Rule 18    scope -> LOCAL
Rule 19    final -> FINAL
Rule 20    final -> BASE
Rule 21    item_decl -> atrib_decl
Rule 22    item_decl -> method_decl
Rule 23    atrib_decl -> type var var_list SEMICOLON
Rule 24    method_decl -> instance type method
Rule 25    type -> INT
Rule 26    type -> FLOAT
Rule 27    type -> DOUBLE
Rule 28    type -> CHAR
Rule 29    type -> VOID
Rule 30    type -> ID value
Rule 31    var -> ID array value
Rule 32    value -> ASSIGNMENT exp
Rule 33    value -> empty
Rule 34    var_list -> COMMA var var_list
Rule 35    var_list -> empty
Rule 36    array -> LSBRACKET RSBRACKET array
Rule 37    array -> empty
Rule 38    method -> ID LPAREN argument RPAREN bloc_com
Rule 39    argument -> type var arg_list
Rule 40    argument -> empty
Rule 41    arg_list -> COMMA argument
Rule 42    arg_list -> empty
Rule 43    bloc_com -> LCURLYBRACE com_list RCURLYBRACE
Rule 44    bloc -> bloc_com
Rule 45    bloc -> command SEMICOLON
Rule 46    com_list -> command com_list
Rule 47    com_list -> empty
Rule 48    command -> atrib SEMICOLON
Rule 49    command -> WHILE LPAREN exp_logic RPAREN bloc
Rule 50    command -> DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON
Rule 51    command -> IF LPAREN exp_logic RPAREN bloc else
Rule 52    command -> FOR LPAREN for_exp RPAREN bloc
Rule 53    command -> SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE
Rule 54    command -> BREAK SEMICOLON
Rule 55    command -> CONTINUE SEMICOLON
Rule 56    command -> RETURN exp SEMICOLON
Rule 57    atrib -> ID name ASSIGNMENT exp
Rule 58    else -> ELSE bloc
Rule 59    else -> empty
Rule 60    for_exp -> atrib_decl SEMICOLON exp_logic SEMICOLON atrib
Rule 61    for_exp -> type ID COLON ID name
Rule 62    switch_case -> CASE const COLON bloc switch_case
Rule 63    switch_case -> DEFAULT bloc
Rule 64    exp -> exp_math
Rule 65    exp -> exp_logic
Rule 66    exp -> operator ID name
Rule 67    exp -> NEW type name
Rule 68    operator -> DOUBLEPLUS
Rule 69    operator -> DOUBLEMINUS
Rule 70    params -> param param_list
Rule 71    params -> empty
Rule 72    param_list -> COMMA param param_list
Rule 73    param_list -> empty
Rule 74    exp_logic -> exp_math op_logic exp_logic_tail
Rule 75    exp_logic -> operator ID name op_logic exp_logic_tail
Rule 76    exp_logic -> NEW type name op_logic exp_logic_tail
Rule 77    exp_logic -> exp_logic_tail
Rule 78    exp_logic_tail -> exp_math
Rule 79    exp_logic_tail -> empty
Rule 80    exp_math -> param op_math exp_math
Rule 81    exp_math -> param
Rule 82    op_logic -> MORETHAN
Rule 83    op_logic -> LESSTHAN
Rule 84    op_logic -> MOREOREQUALTHAN
Rule 85    op_logic -> LESSOREQUALTHAN
Rule 86    op_logic -> DOUBLEEQUALS
Rule 87    op_logic -> NOTEQUAL
Rule 88    op_math -> PLUS
Rule 89    op_math -> MINUS
Rule 90    op_math -> TIMES
Rule 91    op_math -> DIVIDE
Rule 92    param -> ID name
Rule 93    param -> THIS field
Rule 94    param -> const
Rule 95    name -> field
Rule 96    name -> array_size name_non_empty
Rule 97    name -> LPAREN params RPAREN name_non_empty
Rule 98    name -> empty
Rule 99    name_non_empty -> field
Rule 100   name_non_empty -> array_size name_non_empty
Rule 101   name_non_empty -> LPAREN params RPAREN name_non_empty
Rule 102   field -> DOT ID name_non_empty
Rule 103   field -> empty
Rule 104   array_size -> LSBRACKET exp_math RSBRACKET array_size_non_empty
Rule 105   array_size -> empty
Rule 106   array_size_non_empty -> LSBRACKET exp_math RSBRACKET array_size_non_empty
Rule 107   array_size_non_empty -> empty
Rule 108   const -> NUMBER
Rule 109   const -> STRING
Rule 110   const -> CHARACTER
Rule 111   const -> TRUE
Rule 112   const -> FALSE
Rule 113   empty -> <empty>

Terminals, with rules where they appear

ABSTRACT             : 7
ASSIGNMENT           : 32 57
BASE                 : 20
BREAK                : 54
CASE                 : 62
CHAR                 : 28
CHARACTER            : 110
CLASS                : 5
COLON                : 61 62
COMMA                : 34 41 72
CONCRETE             : 8
CONTINUE             : 55
DEFAULT              : 63
DIVIDE               : 91
DO                   : 50
DOT                  : 102
DOUBLE               : 27
DOUBLEEQUALS         : 86
DOUBLEMINUS          : 69
DOUBLEPLUS           : 68
ELSE                 : 58
EXTENDS              : 9
FALSE                : 112
FINAL                : 19
FLOAT                : 26
FOR                  : 52
ID                   : 4 9 10 30 31 38 53 57 61 61 66 75 92 102
IF                   : 51
IMPLEMENTS           : 10
INT                  : 25
INTERFACE            : 6
LCURLYBRACE          : 4 43 53
LESSOREQUALTHAN      : 85
LESSTHAN             : 83
LOCAL                : 18
LPAREN               : 38 49 50 51 52 53 97 101
LSBRACKET            : 36 104 106
MINUS                : 89
MOREOREQUALTHAN      : 84
MORETHAN             : 82
NEW                  : 67 76
NOTEQUAL             : 87
NUMBER               : 108
PLUS                 : 88
PRIVATE              : 16
PROTECTED            : 15
PUBLIC               : 14
RCURLYBRACE          : 4 43 53
RETURN               : 56
RPAREN               : 38 49 50 51 52 53 97 101
RSBRACKET            : 36 104 106
SEMICOLON            : 12 23 45 48 50 54 55 56 60 60
STATIC               : 17
STRING               : 109
SWITCH               : 53
THIS                 : 93
TIMES                : 90
TRUE                 : 111
VOID                 : 29
WHILE                : 49 50
WHITE_SPACE          : 
error                : 

Nonterminals, with rules where they appear

arg_list             : 39
argument             : 38 41
array                : 31 36
array_size           : 96 100
array_size_non_empty : 104 106
atrib                : 48 60
atrib_decl           : 21 60
bloc                 : 49 50 51 52 58 62 63
bloc_com             : 38 44
com_list             : 43 46
command              : 45 46
const                : 62 94
declaration          : 1 2
declarations         : 1 2
else                 : 51
empty                : 3 11 13 33 35 37 40 42 47 59 71 73 79 98 103 105 107
exp                  : 32 56 57
exp_logic            : 49 50 51 60 65
exp_logic_tail       : 74 75 76 77
exp_math             : 64 74 78 80 104 106
field                : 93 95 99
final                : 12
for_exp              : 52
inheritance          : 4
instance             : 5 24
item_decl            : 12
item_decls           : 4 12
method               : 24
method_decl          : 22
name                 : 53 57 61 66 67 75 76 92
name_non_empty       : 96 97 100 101 102
op_logic             : 74 75 76
op_math              : 80
operator             : 66 75
param                : 70 72 80 81
param_list           : 70 72
params               : 97 101
program              : 0
scope                : 12
struct               : 4
switch_case          : 53 62
type                 : 23 24 39 61 67 76
value                : 30 31
var                  : 23 34 39
var_list             : 23 34
visibility           : 12

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declaration declarations
    (4) declaration -> . struct ID inheritance LCURLYBRACE item_decls RCURLYBRACE
    (5) struct -> . instance CLASS
    (6) struct -> . INTERFACE
    (7) instance -> . ABSTRACT
    (8) instance -> . CONCRETE

    INTERFACE       shift and go to state 5
    ABSTRACT        shift and go to state 6
    CONCRETE        shift and go to state 7

    program                        shift and go to state 1
    declaration                    shift and go to state 2
    struct                         shift and go to state 3
    instance                       shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> declaration . declarations
    (2) declarations -> . declaration declarations
    (3) declarations -> . empty
    (4) declaration -> . struct ID inheritance LCURLYBRACE item_decls RCURLYBRACE
    (113) empty -> .
    (5) struct -> . instance CLASS
    (6) struct -> . INTERFACE
    (7) instance -> . ABSTRACT
    (8) instance -> . CONCRETE

    $end            reduce using rule 113 (empty -> .)
    INTERFACE       shift and go to state 5
    ABSTRACT        shift and go to state 6
    CONCRETE        shift and go to state 7

    declaration                    shift and go to state 8
    declarations                   shift and go to state 9
    empty                          shift and go to state 10
    struct                         shift and go to state 3
    instance                       shift and go to state 4

state 3

    (4) declaration -> struct . ID inheritance LCURLYBRACE item_decls RCURLYBRACE

    ID              shift and go to state 11


state 4

    (5) struct -> instance . CLASS

    CLASS           shift and go to state 12


state 5

    (6) struct -> INTERFACE .

    ID              reduce using rule 6 (struct -> INTERFACE .)


state 6

    (7) instance -> ABSTRACT .

    CLASS           reduce using rule 7 (instance -> ABSTRACT .)
    INT             reduce using rule 7 (instance -> ABSTRACT .)
    FLOAT           reduce using rule 7 (instance -> ABSTRACT .)
    DOUBLE          reduce using rule 7 (instance -> ABSTRACT .)
    CHAR            reduce using rule 7 (instance -> ABSTRACT .)
    VOID            reduce using rule 7 (instance -> ABSTRACT .)
    ID              reduce using rule 7 (instance -> ABSTRACT .)


state 7

    (8) instance -> CONCRETE .

    CLASS           reduce using rule 8 (instance -> CONCRETE .)
    INT             reduce using rule 8 (instance -> CONCRETE .)
    FLOAT           reduce using rule 8 (instance -> CONCRETE .)
    DOUBLE          reduce using rule 8 (instance -> CONCRETE .)
    CHAR            reduce using rule 8 (instance -> CONCRETE .)
    VOID            reduce using rule 8 (instance -> CONCRETE .)
    ID              reduce using rule 8 (instance -> CONCRETE .)


state 8

    (2) declarations -> declaration . declarations
    (2) declarations -> . declaration declarations
    (3) declarations -> . empty
    (4) declaration -> . struct ID inheritance LCURLYBRACE item_decls RCURLYBRACE
    (113) empty -> .
    (5) struct -> . instance CLASS
    (6) struct -> . INTERFACE
    (7) instance -> . ABSTRACT
    (8) instance -> . CONCRETE

    $end            reduce using rule 113 (empty -> .)
    INTERFACE       shift and go to state 5
    ABSTRACT        shift and go to state 6
    CONCRETE        shift and go to state 7

    declaration                    shift and go to state 8
    declarations                   shift and go to state 13
    empty                          shift and go to state 10
    struct                         shift and go to state 3
    instance                       shift and go to state 4

state 9

    (1) program -> declaration declarations .

    $end            reduce using rule 1 (program -> declaration declarations .)


state 10

    (3) declarations -> empty .

    $end            reduce using rule 3 (declarations -> empty .)


state 11

    (4) declaration -> struct ID . inheritance LCURLYBRACE item_decls RCURLYBRACE
    (9) inheritance -> . EXTENDS ID
    (10) inheritance -> . IMPLEMENTS ID
    (11) inheritance -> . empty
    (113) empty -> .

    EXTENDS         shift and go to state 15
    IMPLEMENTS      shift and go to state 16
    LCURLYBRACE     reduce using rule 113 (empty -> .)

    inheritance                    shift and go to state 14
    empty                          shift and go to state 17

state 12

    (5) struct -> instance CLASS .

    ID              reduce using rule 5 (struct -> instance CLASS .)


state 13

    (2) declarations -> declaration declarations .

    $end            reduce using rule 2 (declarations -> declaration declarations .)


state 14

    (4) declaration -> struct ID inheritance . LCURLYBRACE item_decls RCURLYBRACE

    LCURLYBRACE     shift and go to state 18


state 15

    (9) inheritance -> EXTENDS . ID

    ID              shift and go to state 19


state 16

    (10) inheritance -> IMPLEMENTS . ID

    ID              shift and go to state 20


state 17

    (11) inheritance -> empty .

    LCURLYBRACE     reduce using rule 11 (inheritance -> empty .)


state 18

    (4) declaration -> struct ID inheritance LCURLYBRACE . item_decls RCURLYBRACE
    (12) item_decls -> . visibility scope final item_decl SEMICOLON item_decls
    (13) item_decls -> . empty
    (14) visibility -> . PUBLIC
    (15) visibility -> . PROTECTED
    (16) visibility -> . PRIVATE
    (113) empty -> .

    PUBLIC          shift and go to state 24
    PROTECTED       shift and go to state 25
    PRIVATE         shift and go to state 26
    RCURLYBRACE     reduce using rule 113 (empty -> .)

    item_decls                     shift and go to state 21
    visibility                     shift and go to state 22
    empty                          shift and go to state 23

state 19

    (9) inheritance -> EXTENDS ID .

    LCURLYBRACE     reduce using rule 9 (inheritance -> EXTENDS ID .)


state 20

    (10) inheritance -> IMPLEMENTS ID .

    LCURLYBRACE     reduce using rule 10 (inheritance -> IMPLEMENTS ID .)


state 21

    (4) declaration -> struct ID inheritance LCURLYBRACE item_decls . RCURLYBRACE

    RCURLYBRACE     shift and go to state 27


state 22

    (12) item_decls -> visibility . scope final item_decl SEMICOLON item_decls
    (17) scope -> . STATIC
    (18) scope -> . LOCAL

    STATIC          shift and go to state 29
    LOCAL           shift and go to state 30

    scope                          shift and go to state 28

state 23

    (13) item_decls -> empty .

    RCURLYBRACE     reduce using rule 13 (item_decls -> empty .)


state 24

    (14) visibility -> PUBLIC .

    STATIC          reduce using rule 14 (visibility -> PUBLIC .)
    LOCAL           reduce using rule 14 (visibility -> PUBLIC .)


state 25

    (15) visibility -> PROTECTED .

    STATIC          reduce using rule 15 (visibility -> PROTECTED .)
    LOCAL           reduce using rule 15 (visibility -> PROTECTED .)


state 26

    (16) visibility -> PRIVATE .

    STATIC          reduce using rule 16 (visibility -> PRIVATE .)
    LOCAL           reduce using rule 16 (visibility -> PRIVATE .)


state 27

    (4) declaration -> struct ID inheritance LCURLYBRACE item_decls RCURLYBRACE .

    INTERFACE       reduce using rule 4 (declaration -> struct ID inheritance LCURLYBRACE item_decls RCURLYBRACE .)
    ABSTRACT        reduce using rule 4 (declaration -> struct ID inheritance LCURLYBRACE item_decls RCURLYBRACE .)
    CONCRETE        reduce using rule 4 (declaration -> struct ID inheritance LCURLYBRACE item_decls RCURLYBRACE .)
    $end            reduce using rule 4 (declaration -> struct ID inheritance LCURLYBRACE item_decls RCURLYBRACE .)


state 28

    (12) item_decls -> visibility scope . final item_decl SEMICOLON item_decls
    (19) final -> . FINAL
    (20) final -> . BASE

    FINAL           shift and go to state 32
    BASE            shift and go to state 33

    final                          shift and go to state 31

state 29

    (17) scope -> STATIC .

    FINAL           reduce using rule 17 (scope -> STATIC .)
    BASE            reduce using rule 17 (scope -> STATIC .)


state 30

    (18) scope -> LOCAL .

    FINAL           reduce using rule 18 (scope -> LOCAL .)
    BASE            reduce using rule 18 (scope -> LOCAL .)


state 31

    (12) item_decls -> visibility scope final . item_decl SEMICOLON item_decls
    (21) item_decl -> . atrib_decl
    (22) item_decl -> . method_decl
    (23) atrib_decl -> . type var var_list SEMICOLON
    (24) method_decl -> . instance type method
    (25) type -> . INT
    (26) type -> . FLOAT
    (27) type -> . DOUBLE
    (28) type -> . CHAR
    (29) type -> . VOID
    (30) type -> . ID value
    (7) instance -> . ABSTRACT
    (8) instance -> . CONCRETE

    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    DOUBLE          shift and go to state 41
    CHAR            shift and go to state 42
    VOID            shift and go to state 43
    ID              shift and go to state 44
    ABSTRACT        shift and go to state 6
    CONCRETE        shift and go to state 7

    item_decl                      shift and go to state 34
    atrib_decl                     shift and go to state 35
    method_decl                    shift and go to state 36
    type                           shift and go to state 37
    instance                       shift and go to state 38

state 32

    (19) final -> FINAL .

    INT             reduce using rule 19 (final -> FINAL .)
    FLOAT           reduce using rule 19 (final -> FINAL .)
    DOUBLE          reduce using rule 19 (final -> FINAL .)
    CHAR            reduce using rule 19 (final -> FINAL .)
    VOID            reduce using rule 19 (final -> FINAL .)
    ID              reduce using rule 19 (final -> FINAL .)
    ABSTRACT        reduce using rule 19 (final -> FINAL .)
    CONCRETE        reduce using rule 19 (final -> FINAL .)


state 33

    (20) final -> BASE .

    INT             reduce using rule 20 (final -> BASE .)
    FLOAT           reduce using rule 20 (final -> BASE .)
    DOUBLE          reduce using rule 20 (final -> BASE .)
    CHAR            reduce using rule 20 (final -> BASE .)
    VOID            reduce using rule 20 (final -> BASE .)
    ID              reduce using rule 20 (final -> BASE .)
    ABSTRACT        reduce using rule 20 (final -> BASE .)
    CONCRETE        reduce using rule 20 (final -> BASE .)


state 34

    (12) item_decls -> visibility scope final item_decl . SEMICOLON item_decls

    SEMICOLON       shift and go to state 45


state 35

    (21) item_decl -> atrib_decl .

    SEMICOLON       reduce using rule 21 (item_decl -> atrib_decl .)


state 36

    (22) item_decl -> method_decl .

    SEMICOLON       reduce using rule 22 (item_decl -> method_decl .)


state 37

    (23) atrib_decl -> type . var var_list SEMICOLON
    (31) var -> . ID array value

    ID              shift and go to state 47

    var                            shift and go to state 46

state 38

    (24) method_decl -> instance . type method
    (25) type -> . INT
    (26) type -> . FLOAT
    (27) type -> . DOUBLE
    (28) type -> . CHAR
    (29) type -> . VOID
    (30) type -> . ID value

    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    DOUBLE          shift and go to state 41
    CHAR            shift and go to state 42
    VOID            shift and go to state 43
    ID              shift and go to state 44

    type                           shift and go to state 48

state 39

    (25) type -> INT .

    ID              reduce using rule 25 (type -> INT .)
    LPAREN          reduce using rule 25 (type -> INT .)
    DOT             reduce using rule 25 (type -> INT .)
    LSBRACKET       reduce using rule 25 (type -> INT .)
    MORETHAN        reduce using rule 25 (type -> INT .)
    LESSTHAN        reduce using rule 25 (type -> INT .)
    MOREOREQUALTHAN reduce using rule 25 (type -> INT .)
    LESSOREQUALTHAN reduce using rule 25 (type -> INT .)
    DOUBLEEQUALS    reduce using rule 25 (type -> INT .)
    NOTEQUAL        reduce using rule 25 (type -> INT .)
    COMMA           reduce using rule 25 (type -> INT .)
    SEMICOLON       reduce using rule 25 (type -> INT .)
    RPAREN          reduce using rule 25 (type -> INT .)


state 40

    (26) type -> FLOAT .

    ID              reduce using rule 26 (type -> FLOAT .)
    LPAREN          reduce using rule 26 (type -> FLOAT .)
    DOT             reduce using rule 26 (type -> FLOAT .)
    LSBRACKET       reduce using rule 26 (type -> FLOAT .)
    MORETHAN        reduce using rule 26 (type -> FLOAT .)
    LESSTHAN        reduce using rule 26 (type -> FLOAT .)
    MOREOREQUALTHAN reduce using rule 26 (type -> FLOAT .)
    LESSOREQUALTHAN reduce using rule 26 (type -> FLOAT .)
    DOUBLEEQUALS    reduce using rule 26 (type -> FLOAT .)
    NOTEQUAL        reduce using rule 26 (type -> FLOAT .)
    COMMA           reduce using rule 26 (type -> FLOAT .)
    SEMICOLON       reduce using rule 26 (type -> FLOAT .)
    RPAREN          reduce using rule 26 (type -> FLOAT .)


state 41

    (27) type -> DOUBLE .

    ID              reduce using rule 27 (type -> DOUBLE .)
    LPAREN          reduce using rule 27 (type -> DOUBLE .)
    DOT             reduce using rule 27 (type -> DOUBLE .)
    LSBRACKET       reduce using rule 27 (type -> DOUBLE .)
    MORETHAN        reduce using rule 27 (type -> DOUBLE .)
    LESSTHAN        reduce using rule 27 (type -> DOUBLE .)
    MOREOREQUALTHAN reduce using rule 27 (type -> DOUBLE .)
    LESSOREQUALTHAN reduce using rule 27 (type -> DOUBLE .)
    DOUBLEEQUALS    reduce using rule 27 (type -> DOUBLE .)
    NOTEQUAL        reduce using rule 27 (type -> DOUBLE .)
    COMMA           reduce using rule 27 (type -> DOUBLE .)
    SEMICOLON       reduce using rule 27 (type -> DOUBLE .)
    RPAREN          reduce using rule 27 (type -> DOUBLE .)


state 42

    (28) type -> CHAR .

    ID              reduce using rule 28 (type -> CHAR .)
    LPAREN          reduce using rule 28 (type -> CHAR .)
    DOT             reduce using rule 28 (type -> CHAR .)
    LSBRACKET       reduce using rule 28 (type -> CHAR .)
    MORETHAN        reduce using rule 28 (type -> CHAR .)
    LESSTHAN        reduce using rule 28 (type -> CHAR .)
    MOREOREQUALTHAN reduce using rule 28 (type -> CHAR .)
    LESSOREQUALTHAN reduce using rule 28 (type -> CHAR .)
    DOUBLEEQUALS    reduce using rule 28 (type -> CHAR .)
    NOTEQUAL        reduce using rule 28 (type -> CHAR .)
    COMMA           reduce using rule 28 (type -> CHAR .)
    SEMICOLON       reduce using rule 28 (type -> CHAR .)
    RPAREN          reduce using rule 28 (type -> CHAR .)


state 43

    (29) type -> VOID .

    ID              reduce using rule 29 (type -> VOID .)
    LPAREN          reduce using rule 29 (type -> VOID .)
    DOT             reduce using rule 29 (type -> VOID .)
    LSBRACKET       reduce using rule 29 (type -> VOID .)
    MORETHAN        reduce using rule 29 (type -> VOID .)
    LESSTHAN        reduce using rule 29 (type -> VOID .)
    MOREOREQUALTHAN reduce using rule 29 (type -> VOID .)
    LESSOREQUALTHAN reduce using rule 29 (type -> VOID .)
    DOUBLEEQUALS    reduce using rule 29 (type -> VOID .)
    NOTEQUAL        reduce using rule 29 (type -> VOID .)
    COMMA           reduce using rule 29 (type -> VOID .)
    SEMICOLON       reduce using rule 29 (type -> VOID .)
    RPAREN          reduce using rule 29 (type -> VOID .)


state 44

    (30) type -> ID . value
    (32) value -> . ASSIGNMENT exp
    (33) value -> . empty
    (113) empty -> .

    ASSIGNMENT      shift and go to state 50
    ID              reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    DOT             reduce using rule 113 (empty -> .)
    LSBRACKET       reduce using rule 113 (empty -> .)
    MORETHAN        reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    MOREOREQUALTHAN reduce using rule 113 (empty -> .)
    LESSOREQUALTHAN reduce using rule 113 (empty -> .)
    DOUBLEEQUALS    reduce using rule 113 (empty -> .)
    NOTEQUAL        reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)

    value                          shift and go to state 49
    empty                          shift and go to state 51

state 45

    (12) item_decls -> visibility scope final item_decl SEMICOLON . item_decls
    (12) item_decls -> . visibility scope final item_decl SEMICOLON item_decls
    (13) item_decls -> . empty
    (14) visibility -> . PUBLIC
    (15) visibility -> . PROTECTED
    (16) visibility -> . PRIVATE
    (113) empty -> .

    PUBLIC          shift and go to state 24
    PROTECTED       shift and go to state 25
    PRIVATE         shift and go to state 26
    RCURLYBRACE     reduce using rule 113 (empty -> .)

    visibility                     shift and go to state 22
    item_decls                     shift and go to state 52
    empty                          shift and go to state 23

state 46

    (23) atrib_decl -> type var . var_list SEMICOLON
    (34) var_list -> . COMMA var var_list
    (35) var_list -> . empty
    (113) empty -> .

    COMMA           shift and go to state 54
    SEMICOLON       reduce using rule 113 (empty -> .)

    var_list                       shift and go to state 53
    empty                          shift and go to state 55

state 47

    (31) var -> ID . array value
    (36) array -> . LSBRACKET RSBRACKET array
    (37) array -> . empty
    (113) empty -> .

    LSBRACKET       shift and go to state 57
    ASSIGNMENT      reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)

    array                          shift and go to state 56
    empty                          shift and go to state 58

state 48

    (24) method_decl -> instance type . method
    (38) method -> . ID LPAREN argument RPAREN bloc_com

    ID              shift and go to state 60

    method                         shift and go to state 59

state 49

    (30) type -> ID value .

    ID              reduce using rule 30 (type -> ID value .)
    LPAREN          reduce using rule 30 (type -> ID value .)
    DOT             reduce using rule 30 (type -> ID value .)
    LSBRACKET       reduce using rule 30 (type -> ID value .)
    MORETHAN        reduce using rule 30 (type -> ID value .)
    LESSTHAN        reduce using rule 30 (type -> ID value .)
    MOREOREQUALTHAN reduce using rule 30 (type -> ID value .)
    LESSOREQUALTHAN reduce using rule 30 (type -> ID value .)
    DOUBLEEQUALS    reduce using rule 30 (type -> ID value .)
    NOTEQUAL        reduce using rule 30 (type -> ID value .)
    COMMA           reduce using rule 30 (type -> ID value .)
    SEMICOLON       reduce using rule 30 (type -> ID value .)
    RPAREN          reduce using rule 30 (type -> ID value .)


state 50

    (32) value -> ASSIGNMENT . exp
    (64) exp -> . exp_math
    (65) exp -> . exp_logic
    (66) exp -> . operator ID name
    (67) exp -> . NEW type name
    (80) exp_math -> . param op_math exp_math
    (81) exp_math -> . param
    (74) exp_logic -> . exp_math op_logic exp_logic_tail
    (75) exp_logic -> . operator ID name op_logic exp_logic_tail
    (76) exp_logic -> . NEW type name op_logic exp_logic_tail
    (77) exp_logic -> . exp_logic_tail
    (68) operator -> . DOUBLEPLUS
    (69) operator -> . DOUBLEMINUS
    (92) param -> . ID name
    (93) param -> . THIS field
    (94) param -> . const
    (78) exp_logic_tail -> . exp_math
    (79) exp_logic_tail -> . empty
    (108) const -> . NUMBER
    (109) const -> . STRING
    (110) const -> . CHARACTER
    (111) const -> . TRUE
    (112) const -> . FALSE
    (113) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    NEW             shift and go to state 66
    DOUBLEPLUS      shift and go to state 69
    DOUBLEMINUS     shift and go to state 70
    ID              shift and go to state 65
    THIS            shift and go to state 71
    NUMBER          shift and go to state 74
    STRING          shift and go to state 75
    CHARACTER       shift and go to state 76
    TRUE            shift and go to state 77
    FALSE           shift and go to state 78
    LPAREN          reduce using rule 113 (empty -> .)
    DOT             reduce using rule 113 (empty -> .)
    LSBRACKET       reduce using rule 113 (empty -> .)
    MORETHAN        reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    MOREOREQUALTHAN reduce using rule 113 (empty -> .)
    LESSOREQUALTHAN reduce using rule 113 (empty -> .)
    DOUBLEEQUALS    reduce using rule 113 (empty -> .)
    NOTEQUAL        reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)

  ! ID              [ reduce using rule 113 (empty -> .) ]

    exp                            shift and go to state 61
    exp_math                       shift and go to state 62
    exp_logic                      shift and go to state 63
    operator                       shift and go to state 64
    param                          shift and go to state 67
    exp_logic_tail                 shift and go to state 68
    const                          shift and go to state 72
    empty                          shift and go to state 73

state 51

    (33) value -> empty .

    ID              reduce using rule 33 (value -> empty .)
    LPAREN          reduce using rule 33 (value -> empty .)
    DOT             reduce using rule 33 (value -> empty .)
    LSBRACKET       reduce using rule 33 (value -> empty .)
    MORETHAN        reduce using rule 33 (value -> empty .)
    LESSTHAN        reduce using rule 33 (value -> empty .)
    MOREOREQUALTHAN reduce using rule 33 (value -> empty .)
    LESSOREQUALTHAN reduce using rule 33 (value -> empty .)
    DOUBLEEQUALS    reduce using rule 33 (value -> empty .)
    NOTEQUAL        reduce using rule 33 (value -> empty .)
    COMMA           reduce using rule 33 (value -> empty .)
    SEMICOLON       reduce using rule 33 (value -> empty .)
    RPAREN          reduce using rule 33 (value -> empty .)


state 52

    (12) item_decls -> visibility scope final item_decl SEMICOLON item_decls .

    RCURLYBRACE     reduce using rule 12 (item_decls -> visibility scope final item_decl SEMICOLON item_decls .)


state 53

    (23) atrib_decl -> type var var_list . SEMICOLON

    SEMICOLON       shift and go to state 79


state 54

    (34) var_list -> COMMA . var var_list
    (31) var -> . ID array value

    ID              shift and go to state 47

    var                            shift and go to state 80

state 55

    (35) var_list -> empty .

    SEMICOLON       reduce using rule 35 (var_list -> empty .)


state 56

    (31) var -> ID array . value
    (32) value -> . ASSIGNMENT exp
    (33) value -> . empty
    (113) empty -> .

    ASSIGNMENT      shift and go to state 50
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)

    value                          shift and go to state 81
    empty                          shift and go to state 51

state 57

    (36) array -> LSBRACKET . RSBRACKET array

    RSBRACKET       shift and go to state 82


state 58

    (37) array -> empty .

    ASSIGNMENT      reduce using rule 37 (array -> empty .)
    COMMA           reduce using rule 37 (array -> empty .)
    SEMICOLON       reduce using rule 37 (array -> empty .)
    RPAREN          reduce using rule 37 (array -> empty .)


state 59

    (24) method_decl -> instance type method .

    SEMICOLON       reduce using rule 24 (method_decl -> instance type method .)


state 60

    (38) method -> ID . LPAREN argument RPAREN bloc_com

    LPAREN          shift and go to state 83


state 61

    (32) value -> ASSIGNMENT exp .

    ID              reduce using rule 32 (value -> ASSIGNMENT exp .)
    LPAREN          reduce using rule 32 (value -> ASSIGNMENT exp .)
    DOT             reduce using rule 32 (value -> ASSIGNMENT exp .)
    LSBRACKET       reduce using rule 32 (value -> ASSIGNMENT exp .)
    MORETHAN        reduce using rule 32 (value -> ASSIGNMENT exp .)
    LESSTHAN        reduce using rule 32 (value -> ASSIGNMENT exp .)
    MOREOREQUALTHAN reduce using rule 32 (value -> ASSIGNMENT exp .)
    LESSOREQUALTHAN reduce using rule 32 (value -> ASSIGNMENT exp .)
    DOUBLEEQUALS    reduce using rule 32 (value -> ASSIGNMENT exp .)
    NOTEQUAL        reduce using rule 32 (value -> ASSIGNMENT exp .)
    COMMA           reduce using rule 32 (value -> ASSIGNMENT exp .)
    SEMICOLON       reduce using rule 32 (value -> ASSIGNMENT exp .)
    RPAREN          reduce using rule 32 (value -> ASSIGNMENT exp .)


state 62

    (64) exp -> exp_math .
    (74) exp_logic -> exp_math . op_logic exp_logic_tail
    (78) exp_logic_tail -> exp_math .
    (82) op_logic -> . MORETHAN
    (83) op_logic -> . LESSTHAN
    (84) op_logic -> . MOREOREQUALTHAN
    (85) op_logic -> . LESSOREQUALTHAN
    (86) op_logic -> . DOUBLEEQUALS
    (87) op_logic -> . NOTEQUAL

  ! reduce/reduce conflict for ID resolved using rule 64 (exp -> exp_math .)
  ! reduce/reduce conflict for LPAREN resolved using rule 64 (exp -> exp_math .)
  ! reduce/reduce conflict for DOT resolved using rule 64 (exp -> exp_math .)
  ! reduce/reduce conflict for LSBRACKET resolved using rule 64 (exp -> exp_math .)
  ! reduce/reduce conflict for MORETHAN resolved using rule 64 (exp -> exp_math .)
  ! reduce/reduce conflict for LESSTHAN resolved using rule 64 (exp -> exp_math .)
  ! reduce/reduce conflict for MOREOREQUALTHAN resolved using rule 64 (exp -> exp_math .)
  ! reduce/reduce conflict for LESSOREQUALTHAN resolved using rule 64 (exp -> exp_math .)
  ! reduce/reduce conflict for DOUBLEEQUALS resolved using rule 64 (exp -> exp_math .)
  ! reduce/reduce conflict for NOTEQUAL resolved using rule 64 (exp -> exp_math .)
  ! reduce/reduce conflict for COMMA resolved using rule 64 (exp -> exp_math .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 64 (exp -> exp_math .)
  ! reduce/reduce conflict for RPAREN resolved using rule 64 (exp -> exp_math .)
  ! shift/reduce conflict for MORETHAN resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for MOREOREQUALTHAN resolved as shift
  ! shift/reduce conflict for LESSOREQUALTHAN resolved as shift
  ! shift/reduce conflict for DOUBLEEQUALS resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
    ID              reduce using rule 64 (exp -> exp_math .)
    LPAREN          reduce using rule 64 (exp -> exp_math .)
    DOT             reduce using rule 64 (exp -> exp_math .)
    LSBRACKET       reduce using rule 64 (exp -> exp_math .)
    COMMA           reduce using rule 64 (exp -> exp_math .)
    SEMICOLON       reduce using rule 64 (exp -> exp_math .)
    RPAREN          reduce using rule 64 (exp -> exp_math .)
    MORETHAN        shift and go to state 85
    LESSTHAN        shift and go to state 86
    MOREOREQUALTHAN shift and go to state 87
    LESSOREQUALTHAN shift and go to state 88
    DOUBLEEQUALS    shift and go to state 89
    NOTEQUAL        shift and go to state 90

  ! MORETHAN        [ reduce using rule 64 (exp -> exp_math .) ]
  ! LESSTHAN        [ reduce using rule 64 (exp -> exp_math .) ]
  ! MOREOREQUALTHAN [ reduce using rule 64 (exp -> exp_math .) ]
  ! LESSOREQUALTHAN [ reduce using rule 64 (exp -> exp_math .) ]
  ! DOUBLEEQUALS    [ reduce using rule 64 (exp -> exp_math .) ]
  ! NOTEQUAL        [ reduce using rule 64 (exp -> exp_math .) ]
  ! ID              [ reduce using rule 78 (exp_logic_tail -> exp_math .) ]
  ! LPAREN          [ reduce using rule 78 (exp_logic_tail -> exp_math .) ]
  ! DOT             [ reduce using rule 78 (exp_logic_tail -> exp_math .) ]
  ! LSBRACKET       [ reduce using rule 78 (exp_logic_tail -> exp_math .) ]
  ! MORETHAN        [ reduce using rule 78 (exp_logic_tail -> exp_math .) ]
  ! LESSTHAN        [ reduce using rule 78 (exp_logic_tail -> exp_math .) ]
  ! MOREOREQUALTHAN [ reduce using rule 78 (exp_logic_tail -> exp_math .) ]
  ! LESSOREQUALTHAN [ reduce using rule 78 (exp_logic_tail -> exp_math .) ]
  ! DOUBLEEQUALS    [ reduce using rule 78 (exp_logic_tail -> exp_math .) ]
  ! NOTEQUAL        [ reduce using rule 78 (exp_logic_tail -> exp_math .) ]
  ! COMMA           [ reduce using rule 78 (exp_logic_tail -> exp_math .) ]
  ! SEMICOLON       [ reduce using rule 78 (exp_logic_tail -> exp_math .) ]
  ! RPAREN          [ reduce using rule 78 (exp_logic_tail -> exp_math .) ]

    op_logic                       shift and go to state 84

state 63

    (65) exp -> exp_logic .

    ID              reduce using rule 65 (exp -> exp_logic .)
    LPAREN          reduce using rule 65 (exp -> exp_logic .)
    DOT             reduce using rule 65 (exp -> exp_logic .)
    LSBRACKET       reduce using rule 65 (exp -> exp_logic .)
    MORETHAN        reduce using rule 65 (exp -> exp_logic .)
    LESSTHAN        reduce using rule 65 (exp -> exp_logic .)
    MOREOREQUALTHAN reduce using rule 65 (exp -> exp_logic .)
    LESSOREQUALTHAN reduce using rule 65 (exp -> exp_logic .)
    DOUBLEEQUALS    reduce using rule 65 (exp -> exp_logic .)
    NOTEQUAL        reduce using rule 65 (exp -> exp_logic .)
    COMMA           reduce using rule 65 (exp -> exp_logic .)
    SEMICOLON       reduce using rule 65 (exp -> exp_logic .)
    RPAREN          reduce using rule 65 (exp -> exp_logic .)


state 64

    (66) exp -> operator . ID name
    (75) exp_logic -> operator . ID name op_logic exp_logic_tail

    ID              shift and go to state 91


state 65

    (92) param -> ID . name
    (95) name -> . field
    (96) name -> . array_size name_non_empty
    (97) name -> . LPAREN params RPAREN name_non_empty
    (98) name -> . empty
    (102) field -> . DOT ID name_non_empty
    (103) field -> . empty
    (104) array_size -> . LSBRACKET exp_math RSBRACKET array_size_non_empty
    (105) array_size -> . empty
    (113) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LSBRACKET resolved as shift
    LPAREN          shift and go to state 95
    DOT             shift and go to state 97
    LSBRACKET       shift and go to state 98
    PLUS            reduce using rule 113 (empty -> .)
    MINUS           reduce using rule 113 (empty -> .)
    TIMES           reduce using rule 113 (empty -> .)
    DIVIDE          reduce using rule 113 (empty -> .)
    MORETHAN        reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    MOREOREQUALTHAN reduce using rule 113 (empty -> .)
    LESSOREQUALTHAN reduce using rule 113 (empty -> .)
    DOUBLEEQUALS    reduce using rule 113 (empty -> .)
    NOTEQUAL        reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    RSBRACKET       reduce using rule 113 (empty -> .)

  ! LPAREN          [ reduce using rule 113 (empty -> .) ]
  ! DOT             [ reduce using rule 113 (empty -> .) ]
  ! LSBRACKET       [ reduce using rule 113 (empty -> .) ]

    name                           shift and go to state 92
    field                          shift and go to state 93
    array_size                     shift and go to state 94
    empty                          shift and go to state 96

state 66

    (67) exp -> NEW . type name
    (76) exp_logic -> NEW . type name op_logic exp_logic_tail
    (25) type -> . INT
    (26) type -> . FLOAT
    (27) type -> . DOUBLE
    (28) type -> . CHAR
    (29) type -> . VOID
    (30) type -> . ID value

    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    DOUBLE          shift and go to state 41
    CHAR            shift and go to state 42
    VOID            shift and go to state 43
    ID              shift and go to state 44

    type                           shift and go to state 99

state 67

    (80) exp_math -> param . op_math exp_math
    (81) exp_math -> param .
    (88) op_math -> . PLUS
    (89) op_math -> . MINUS
    (90) op_math -> . TIMES
    (91) op_math -> . DIVIDE

    MORETHAN        reduce using rule 81 (exp_math -> param .)
    LESSTHAN        reduce using rule 81 (exp_math -> param .)
    MOREOREQUALTHAN reduce using rule 81 (exp_math -> param .)
    LESSOREQUALTHAN reduce using rule 81 (exp_math -> param .)
    DOUBLEEQUALS    reduce using rule 81 (exp_math -> param .)
    NOTEQUAL        reduce using rule 81 (exp_math -> param .)
    ID              reduce using rule 81 (exp_math -> param .)
    LPAREN          reduce using rule 81 (exp_math -> param .)
    DOT             reduce using rule 81 (exp_math -> param .)
    LSBRACKET       reduce using rule 81 (exp_math -> param .)
    COMMA           reduce using rule 81 (exp_math -> param .)
    SEMICOLON       reduce using rule 81 (exp_math -> param .)
    RPAREN          reduce using rule 81 (exp_math -> param .)
    RSBRACKET       reduce using rule 81 (exp_math -> param .)
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVIDE          shift and go to state 104

    op_math                        shift and go to state 100

state 68

    (77) exp_logic -> exp_logic_tail .

    ID              reduce using rule 77 (exp_logic -> exp_logic_tail .)
    LPAREN          reduce using rule 77 (exp_logic -> exp_logic_tail .)
    DOT             reduce using rule 77 (exp_logic -> exp_logic_tail .)
    LSBRACKET       reduce using rule 77 (exp_logic -> exp_logic_tail .)
    MORETHAN        reduce using rule 77 (exp_logic -> exp_logic_tail .)
    LESSTHAN        reduce using rule 77 (exp_logic -> exp_logic_tail .)
    MOREOREQUALTHAN reduce using rule 77 (exp_logic -> exp_logic_tail .)
    LESSOREQUALTHAN reduce using rule 77 (exp_logic -> exp_logic_tail .)
    DOUBLEEQUALS    reduce using rule 77 (exp_logic -> exp_logic_tail .)
    NOTEQUAL        reduce using rule 77 (exp_logic -> exp_logic_tail .)
    COMMA           reduce using rule 77 (exp_logic -> exp_logic_tail .)
    SEMICOLON       reduce using rule 77 (exp_logic -> exp_logic_tail .)
    RPAREN          reduce using rule 77 (exp_logic -> exp_logic_tail .)


state 69

    (68) operator -> DOUBLEPLUS .

    ID              reduce using rule 68 (operator -> DOUBLEPLUS .)


state 70

    (69) operator -> DOUBLEMINUS .

    ID              reduce using rule 69 (operator -> DOUBLEMINUS .)


state 71

    (93) param -> THIS . field
    (102) field -> . DOT ID name_non_empty
    (103) field -> . empty
    (113) empty -> .

  ! shift/reduce conflict for DOT resolved as shift
    DOT             shift and go to state 97
    PLUS            reduce using rule 113 (empty -> .)
    MINUS           reduce using rule 113 (empty -> .)
    TIMES           reduce using rule 113 (empty -> .)
    DIVIDE          reduce using rule 113 (empty -> .)
    MORETHAN        reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    MOREOREQUALTHAN reduce using rule 113 (empty -> .)
    LESSOREQUALTHAN reduce using rule 113 (empty -> .)
    DOUBLEEQUALS    reduce using rule 113 (empty -> .)
    NOTEQUAL        reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    LPAREN          reduce using rule 113 (empty -> .)
    LSBRACKET       reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    RSBRACKET       reduce using rule 113 (empty -> .)

  ! DOT             [ reduce using rule 113 (empty -> .) ]

    field                          shift and go to state 105
    empty                          shift and go to state 106

state 72

    (94) param -> const .

    PLUS            reduce using rule 94 (param -> const .)
    MINUS           reduce using rule 94 (param -> const .)
    TIMES           reduce using rule 94 (param -> const .)
    DIVIDE          reduce using rule 94 (param -> const .)
    MORETHAN        reduce using rule 94 (param -> const .)
    LESSTHAN        reduce using rule 94 (param -> const .)
    MOREOREQUALTHAN reduce using rule 94 (param -> const .)
    LESSOREQUALTHAN reduce using rule 94 (param -> const .)
    DOUBLEEQUALS    reduce using rule 94 (param -> const .)
    NOTEQUAL        reduce using rule 94 (param -> const .)
    ID              reduce using rule 94 (param -> const .)
    LPAREN          reduce using rule 94 (param -> const .)
    DOT             reduce using rule 94 (param -> const .)
    LSBRACKET       reduce using rule 94 (param -> const .)
    COMMA           reduce using rule 94 (param -> const .)
    SEMICOLON       reduce using rule 94 (param -> const .)
    RPAREN          reduce using rule 94 (param -> const .)
    RSBRACKET       reduce using rule 94 (param -> const .)


state 73

    (79) exp_logic_tail -> empty .

    ID              reduce using rule 79 (exp_logic_tail -> empty .)
    LPAREN          reduce using rule 79 (exp_logic_tail -> empty .)
    DOT             reduce using rule 79 (exp_logic_tail -> empty .)
    LSBRACKET       reduce using rule 79 (exp_logic_tail -> empty .)
    MORETHAN        reduce using rule 79 (exp_logic_tail -> empty .)
    LESSTHAN        reduce using rule 79 (exp_logic_tail -> empty .)
    MOREOREQUALTHAN reduce using rule 79 (exp_logic_tail -> empty .)
    LESSOREQUALTHAN reduce using rule 79 (exp_logic_tail -> empty .)
    DOUBLEEQUALS    reduce using rule 79 (exp_logic_tail -> empty .)
    NOTEQUAL        reduce using rule 79 (exp_logic_tail -> empty .)
    COMMA           reduce using rule 79 (exp_logic_tail -> empty .)
    SEMICOLON       reduce using rule 79 (exp_logic_tail -> empty .)
    RPAREN          reduce using rule 79 (exp_logic_tail -> empty .)


state 74

    (108) const -> NUMBER .

    PLUS            reduce using rule 108 (const -> NUMBER .)
    MINUS           reduce using rule 108 (const -> NUMBER .)
    TIMES           reduce using rule 108 (const -> NUMBER .)
    DIVIDE          reduce using rule 108 (const -> NUMBER .)
    MORETHAN        reduce using rule 108 (const -> NUMBER .)
    LESSTHAN        reduce using rule 108 (const -> NUMBER .)
    MOREOREQUALTHAN reduce using rule 108 (const -> NUMBER .)
    LESSOREQUALTHAN reduce using rule 108 (const -> NUMBER .)
    DOUBLEEQUALS    reduce using rule 108 (const -> NUMBER .)
    NOTEQUAL        reduce using rule 108 (const -> NUMBER .)
    ID              reduce using rule 108 (const -> NUMBER .)
    LPAREN          reduce using rule 108 (const -> NUMBER .)
    DOT             reduce using rule 108 (const -> NUMBER .)
    LSBRACKET       reduce using rule 108 (const -> NUMBER .)
    COMMA           reduce using rule 108 (const -> NUMBER .)
    SEMICOLON       reduce using rule 108 (const -> NUMBER .)
    RPAREN          reduce using rule 108 (const -> NUMBER .)
    RSBRACKET       reduce using rule 108 (const -> NUMBER .)
    COLON           reduce using rule 108 (const -> NUMBER .)


state 75

    (109) const -> STRING .

    PLUS            reduce using rule 109 (const -> STRING .)
    MINUS           reduce using rule 109 (const -> STRING .)
    TIMES           reduce using rule 109 (const -> STRING .)
    DIVIDE          reduce using rule 109 (const -> STRING .)
    MORETHAN        reduce using rule 109 (const -> STRING .)
    LESSTHAN        reduce using rule 109 (const -> STRING .)
    MOREOREQUALTHAN reduce using rule 109 (const -> STRING .)
    LESSOREQUALTHAN reduce using rule 109 (const -> STRING .)
    DOUBLEEQUALS    reduce using rule 109 (const -> STRING .)
    NOTEQUAL        reduce using rule 109 (const -> STRING .)
    ID              reduce using rule 109 (const -> STRING .)
    LPAREN          reduce using rule 109 (const -> STRING .)
    DOT             reduce using rule 109 (const -> STRING .)
    LSBRACKET       reduce using rule 109 (const -> STRING .)
    COMMA           reduce using rule 109 (const -> STRING .)
    SEMICOLON       reduce using rule 109 (const -> STRING .)
    RPAREN          reduce using rule 109 (const -> STRING .)
    RSBRACKET       reduce using rule 109 (const -> STRING .)
    COLON           reduce using rule 109 (const -> STRING .)


state 76

    (110) const -> CHARACTER .

    PLUS            reduce using rule 110 (const -> CHARACTER .)
    MINUS           reduce using rule 110 (const -> CHARACTER .)
    TIMES           reduce using rule 110 (const -> CHARACTER .)
    DIVIDE          reduce using rule 110 (const -> CHARACTER .)
    MORETHAN        reduce using rule 110 (const -> CHARACTER .)
    LESSTHAN        reduce using rule 110 (const -> CHARACTER .)
    MOREOREQUALTHAN reduce using rule 110 (const -> CHARACTER .)
    LESSOREQUALTHAN reduce using rule 110 (const -> CHARACTER .)
    DOUBLEEQUALS    reduce using rule 110 (const -> CHARACTER .)
    NOTEQUAL        reduce using rule 110 (const -> CHARACTER .)
    ID              reduce using rule 110 (const -> CHARACTER .)
    LPAREN          reduce using rule 110 (const -> CHARACTER .)
    DOT             reduce using rule 110 (const -> CHARACTER .)
    LSBRACKET       reduce using rule 110 (const -> CHARACTER .)
    COMMA           reduce using rule 110 (const -> CHARACTER .)
    SEMICOLON       reduce using rule 110 (const -> CHARACTER .)
    RPAREN          reduce using rule 110 (const -> CHARACTER .)
    RSBRACKET       reduce using rule 110 (const -> CHARACTER .)
    COLON           reduce using rule 110 (const -> CHARACTER .)


state 77

    (111) const -> TRUE .

    PLUS            reduce using rule 111 (const -> TRUE .)
    MINUS           reduce using rule 111 (const -> TRUE .)
    TIMES           reduce using rule 111 (const -> TRUE .)
    DIVIDE          reduce using rule 111 (const -> TRUE .)
    MORETHAN        reduce using rule 111 (const -> TRUE .)
    LESSTHAN        reduce using rule 111 (const -> TRUE .)
    MOREOREQUALTHAN reduce using rule 111 (const -> TRUE .)
    LESSOREQUALTHAN reduce using rule 111 (const -> TRUE .)
    DOUBLEEQUALS    reduce using rule 111 (const -> TRUE .)
    NOTEQUAL        reduce using rule 111 (const -> TRUE .)
    ID              reduce using rule 111 (const -> TRUE .)
    LPAREN          reduce using rule 111 (const -> TRUE .)
    DOT             reduce using rule 111 (const -> TRUE .)
    LSBRACKET       reduce using rule 111 (const -> TRUE .)
    COMMA           reduce using rule 111 (const -> TRUE .)
    SEMICOLON       reduce using rule 111 (const -> TRUE .)
    RPAREN          reduce using rule 111 (const -> TRUE .)
    RSBRACKET       reduce using rule 111 (const -> TRUE .)
    COLON           reduce using rule 111 (const -> TRUE .)


state 78

    (112) const -> FALSE .

    PLUS            reduce using rule 112 (const -> FALSE .)
    MINUS           reduce using rule 112 (const -> FALSE .)
    TIMES           reduce using rule 112 (const -> FALSE .)
    DIVIDE          reduce using rule 112 (const -> FALSE .)
    MORETHAN        reduce using rule 112 (const -> FALSE .)
    LESSTHAN        reduce using rule 112 (const -> FALSE .)
    MOREOREQUALTHAN reduce using rule 112 (const -> FALSE .)
    LESSOREQUALTHAN reduce using rule 112 (const -> FALSE .)
    DOUBLEEQUALS    reduce using rule 112 (const -> FALSE .)
    NOTEQUAL        reduce using rule 112 (const -> FALSE .)
    ID              reduce using rule 112 (const -> FALSE .)
    LPAREN          reduce using rule 112 (const -> FALSE .)
    DOT             reduce using rule 112 (const -> FALSE .)
    LSBRACKET       reduce using rule 112 (const -> FALSE .)
    COMMA           reduce using rule 112 (const -> FALSE .)
    SEMICOLON       reduce using rule 112 (const -> FALSE .)
    RPAREN          reduce using rule 112 (const -> FALSE .)
    RSBRACKET       reduce using rule 112 (const -> FALSE .)
    COLON           reduce using rule 112 (const -> FALSE .)


state 79

    (23) atrib_decl -> type var var_list SEMICOLON .

    SEMICOLON       reduce using rule 23 (atrib_decl -> type var var_list SEMICOLON .)


state 80

    (34) var_list -> COMMA var . var_list
    (34) var_list -> . COMMA var var_list
    (35) var_list -> . empty
    (113) empty -> .

    COMMA           shift and go to state 54
    SEMICOLON       reduce using rule 113 (empty -> .)

    var_list                       shift and go to state 107
    empty                          shift and go to state 55

state 81

    (31) var -> ID array value .

    COMMA           reduce using rule 31 (var -> ID array value .)
    SEMICOLON       reduce using rule 31 (var -> ID array value .)
    RPAREN          reduce using rule 31 (var -> ID array value .)


state 82

    (36) array -> LSBRACKET RSBRACKET . array
    (36) array -> . LSBRACKET RSBRACKET array
    (37) array -> . empty
    (113) empty -> .

    LSBRACKET       shift and go to state 57
    ASSIGNMENT      reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)

    array                          shift and go to state 108
    empty                          shift and go to state 58

state 83

    (38) method -> ID LPAREN . argument RPAREN bloc_com
    (39) argument -> . type var arg_list
    (40) argument -> . empty
    (25) type -> . INT
    (26) type -> . FLOAT
    (27) type -> . DOUBLE
    (28) type -> . CHAR
    (29) type -> . VOID
    (30) type -> . ID value
    (113) empty -> .

    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    DOUBLE          shift and go to state 41
    CHAR            shift and go to state 42
    VOID            shift and go to state 43
    ID              shift and go to state 44
    RPAREN          reduce using rule 113 (empty -> .)

    argument                       shift and go to state 109
    type                           shift and go to state 110
    empty                          shift and go to state 111

state 84

    (74) exp_logic -> exp_math op_logic . exp_logic_tail
    (78) exp_logic_tail -> . exp_math
    (79) exp_logic_tail -> . empty
    (80) exp_math -> . param op_math exp_math
    (81) exp_math -> . param
    (113) empty -> .
    (92) param -> . ID name
    (93) param -> . THIS field
    (94) param -> . const
    (108) const -> . NUMBER
    (109) const -> . STRING
    (110) const -> . CHARACTER
    (111) const -> . TRUE
    (112) const -> . FALSE

  ! shift/reduce conflict for ID resolved as shift
    LPAREN          reduce using rule 113 (empty -> .)
    DOT             reduce using rule 113 (empty -> .)
    LSBRACKET       reduce using rule 113 (empty -> .)
    MORETHAN        reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    MOREOREQUALTHAN reduce using rule 113 (empty -> .)
    LESSOREQUALTHAN reduce using rule 113 (empty -> .)
    DOUBLEEQUALS    reduce using rule 113 (empty -> .)
    NOTEQUAL        reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    ID              shift and go to state 65
    THIS            shift and go to state 71
    NUMBER          shift and go to state 74
    STRING          shift and go to state 75
    CHARACTER       shift and go to state 76
    TRUE            shift and go to state 77
    FALSE           shift and go to state 78

  ! ID              [ reduce using rule 113 (empty -> .) ]

    exp_math                       shift and go to state 112
    exp_logic_tail                 shift and go to state 113
    empty                          shift and go to state 73
    param                          shift and go to state 67
    const                          shift and go to state 72

state 85

    (82) op_logic -> MORETHAN .

    ID              reduce using rule 82 (op_logic -> MORETHAN .)
    THIS            reduce using rule 82 (op_logic -> MORETHAN .)
    NUMBER          reduce using rule 82 (op_logic -> MORETHAN .)
    STRING          reduce using rule 82 (op_logic -> MORETHAN .)
    CHARACTER       reduce using rule 82 (op_logic -> MORETHAN .)
    TRUE            reduce using rule 82 (op_logic -> MORETHAN .)
    FALSE           reduce using rule 82 (op_logic -> MORETHAN .)
    LPAREN          reduce using rule 82 (op_logic -> MORETHAN .)
    DOT             reduce using rule 82 (op_logic -> MORETHAN .)
    LSBRACKET       reduce using rule 82 (op_logic -> MORETHAN .)
    MORETHAN        reduce using rule 82 (op_logic -> MORETHAN .)
    LESSTHAN        reduce using rule 82 (op_logic -> MORETHAN .)
    MOREOREQUALTHAN reduce using rule 82 (op_logic -> MORETHAN .)
    LESSOREQUALTHAN reduce using rule 82 (op_logic -> MORETHAN .)
    DOUBLEEQUALS    reduce using rule 82 (op_logic -> MORETHAN .)
    NOTEQUAL        reduce using rule 82 (op_logic -> MORETHAN .)
    COMMA           reduce using rule 82 (op_logic -> MORETHAN .)
    SEMICOLON       reduce using rule 82 (op_logic -> MORETHAN .)
    RPAREN          reduce using rule 82 (op_logic -> MORETHAN .)


state 86

    (83) op_logic -> LESSTHAN .

    ID              reduce using rule 83 (op_logic -> LESSTHAN .)
    THIS            reduce using rule 83 (op_logic -> LESSTHAN .)
    NUMBER          reduce using rule 83 (op_logic -> LESSTHAN .)
    STRING          reduce using rule 83 (op_logic -> LESSTHAN .)
    CHARACTER       reduce using rule 83 (op_logic -> LESSTHAN .)
    TRUE            reduce using rule 83 (op_logic -> LESSTHAN .)
    FALSE           reduce using rule 83 (op_logic -> LESSTHAN .)
    LPAREN          reduce using rule 83 (op_logic -> LESSTHAN .)
    DOT             reduce using rule 83 (op_logic -> LESSTHAN .)
    LSBRACKET       reduce using rule 83 (op_logic -> LESSTHAN .)
    MORETHAN        reduce using rule 83 (op_logic -> LESSTHAN .)
    LESSTHAN        reduce using rule 83 (op_logic -> LESSTHAN .)
    MOREOREQUALTHAN reduce using rule 83 (op_logic -> LESSTHAN .)
    LESSOREQUALTHAN reduce using rule 83 (op_logic -> LESSTHAN .)
    DOUBLEEQUALS    reduce using rule 83 (op_logic -> LESSTHAN .)
    NOTEQUAL        reduce using rule 83 (op_logic -> LESSTHAN .)
    COMMA           reduce using rule 83 (op_logic -> LESSTHAN .)
    SEMICOLON       reduce using rule 83 (op_logic -> LESSTHAN .)
    RPAREN          reduce using rule 83 (op_logic -> LESSTHAN .)


state 87

    (84) op_logic -> MOREOREQUALTHAN .

    ID              reduce using rule 84 (op_logic -> MOREOREQUALTHAN .)
    THIS            reduce using rule 84 (op_logic -> MOREOREQUALTHAN .)
    NUMBER          reduce using rule 84 (op_logic -> MOREOREQUALTHAN .)
    STRING          reduce using rule 84 (op_logic -> MOREOREQUALTHAN .)
    CHARACTER       reduce using rule 84 (op_logic -> MOREOREQUALTHAN .)
    TRUE            reduce using rule 84 (op_logic -> MOREOREQUALTHAN .)
    FALSE           reduce using rule 84 (op_logic -> MOREOREQUALTHAN .)
    LPAREN          reduce using rule 84 (op_logic -> MOREOREQUALTHAN .)
    DOT             reduce using rule 84 (op_logic -> MOREOREQUALTHAN .)
    LSBRACKET       reduce using rule 84 (op_logic -> MOREOREQUALTHAN .)
    MORETHAN        reduce using rule 84 (op_logic -> MOREOREQUALTHAN .)
    LESSTHAN        reduce using rule 84 (op_logic -> MOREOREQUALTHAN .)
    MOREOREQUALTHAN reduce using rule 84 (op_logic -> MOREOREQUALTHAN .)
    LESSOREQUALTHAN reduce using rule 84 (op_logic -> MOREOREQUALTHAN .)
    DOUBLEEQUALS    reduce using rule 84 (op_logic -> MOREOREQUALTHAN .)
    NOTEQUAL        reduce using rule 84 (op_logic -> MOREOREQUALTHAN .)
    COMMA           reduce using rule 84 (op_logic -> MOREOREQUALTHAN .)
    SEMICOLON       reduce using rule 84 (op_logic -> MOREOREQUALTHAN .)
    RPAREN          reduce using rule 84 (op_logic -> MOREOREQUALTHAN .)


state 88

    (85) op_logic -> LESSOREQUALTHAN .

    ID              reduce using rule 85 (op_logic -> LESSOREQUALTHAN .)
    THIS            reduce using rule 85 (op_logic -> LESSOREQUALTHAN .)
    NUMBER          reduce using rule 85 (op_logic -> LESSOREQUALTHAN .)
    STRING          reduce using rule 85 (op_logic -> LESSOREQUALTHAN .)
    CHARACTER       reduce using rule 85 (op_logic -> LESSOREQUALTHAN .)
    TRUE            reduce using rule 85 (op_logic -> LESSOREQUALTHAN .)
    FALSE           reduce using rule 85 (op_logic -> LESSOREQUALTHAN .)
    LPAREN          reduce using rule 85 (op_logic -> LESSOREQUALTHAN .)
    DOT             reduce using rule 85 (op_logic -> LESSOREQUALTHAN .)
    LSBRACKET       reduce using rule 85 (op_logic -> LESSOREQUALTHAN .)
    MORETHAN        reduce using rule 85 (op_logic -> LESSOREQUALTHAN .)
    LESSTHAN        reduce using rule 85 (op_logic -> LESSOREQUALTHAN .)
    MOREOREQUALTHAN reduce using rule 85 (op_logic -> LESSOREQUALTHAN .)
    LESSOREQUALTHAN reduce using rule 85 (op_logic -> LESSOREQUALTHAN .)
    DOUBLEEQUALS    reduce using rule 85 (op_logic -> LESSOREQUALTHAN .)
    NOTEQUAL        reduce using rule 85 (op_logic -> LESSOREQUALTHAN .)
    COMMA           reduce using rule 85 (op_logic -> LESSOREQUALTHAN .)
    SEMICOLON       reduce using rule 85 (op_logic -> LESSOREQUALTHAN .)
    RPAREN          reduce using rule 85 (op_logic -> LESSOREQUALTHAN .)


state 89

    (86) op_logic -> DOUBLEEQUALS .

    ID              reduce using rule 86 (op_logic -> DOUBLEEQUALS .)
    THIS            reduce using rule 86 (op_logic -> DOUBLEEQUALS .)
    NUMBER          reduce using rule 86 (op_logic -> DOUBLEEQUALS .)
    STRING          reduce using rule 86 (op_logic -> DOUBLEEQUALS .)
    CHARACTER       reduce using rule 86 (op_logic -> DOUBLEEQUALS .)
    TRUE            reduce using rule 86 (op_logic -> DOUBLEEQUALS .)
    FALSE           reduce using rule 86 (op_logic -> DOUBLEEQUALS .)
    LPAREN          reduce using rule 86 (op_logic -> DOUBLEEQUALS .)
    DOT             reduce using rule 86 (op_logic -> DOUBLEEQUALS .)
    LSBRACKET       reduce using rule 86 (op_logic -> DOUBLEEQUALS .)
    MORETHAN        reduce using rule 86 (op_logic -> DOUBLEEQUALS .)
    LESSTHAN        reduce using rule 86 (op_logic -> DOUBLEEQUALS .)
    MOREOREQUALTHAN reduce using rule 86 (op_logic -> DOUBLEEQUALS .)
    LESSOREQUALTHAN reduce using rule 86 (op_logic -> DOUBLEEQUALS .)
    DOUBLEEQUALS    reduce using rule 86 (op_logic -> DOUBLEEQUALS .)
    NOTEQUAL        reduce using rule 86 (op_logic -> DOUBLEEQUALS .)
    COMMA           reduce using rule 86 (op_logic -> DOUBLEEQUALS .)
    SEMICOLON       reduce using rule 86 (op_logic -> DOUBLEEQUALS .)
    RPAREN          reduce using rule 86 (op_logic -> DOUBLEEQUALS .)


state 90

    (87) op_logic -> NOTEQUAL .

    ID              reduce using rule 87 (op_logic -> NOTEQUAL .)
    THIS            reduce using rule 87 (op_logic -> NOTEQUAL .)
    NUMBER          reduce using rule 87 (op_logic -> NOTEQUAL .)
    STRING          reduce using rule 87 (op_logic -> NOTEQUAL .)
    CHARACTER       reduce using rule 87 (op_logic -> NOTEQUAL .)
    TRUE            reduce using rule 87 (op_logic -> NOTEQUAL .)
    FALSE           reduce using rule 87 (op_logic -> NOTEQUAL .)
    LPAREN          reduce using rule 87 (op_logic -> NOTEQUAL .)
    DOT             reduce using rule 87 (op_logic -> NOTEQUAL .)
    LSBRACKET       reduce using rule 87 (op_logic -> NOTEQUAL .)
    MORETHAN        reduce using rule 87 (op_logic -> NOTEQUAL .)
    LESSTHAN        reduce using rule 87 (op_logic -> NOTEQUAL .)
    MOREOREQUALTHAN reduce using rule 87 (op_logic -> NOTEQUAL .)
    LESSOREQUALTHAN reduce using rule 87 (op_logic -> NOTEQUAL .)
    DOUBLEEQUALS    reduce using rule 87 (op_logic -> NOTEQUAL .)
    NOTEQUAL        reduce using rule 87 (op_logic -> NOTEQUAL .)
    COMMA           reduce using rule 87 (op_logic -> NOTEQUAL .)
    SEMICOLON       reduce using rule 87 (op_logic -> NOTEQUAL .)
    RPAREN          reduce using rule 87 (op_logic -> NOTEQUAL .)


state 91

    (66) exp -> operator ID . name
    (75) exp_logic -> operator ID . name op_logic exp_logic_tail
    (95) name -> . field
    (96) name -> . array_size name_non_empty
    (97) name -> . LPAREN params RPAREN name_non_empty
    (98) name -> . empty
    (102) field -> . DOT ID name_non_empty
    (103) field -> . empty
    (104) array_size -> . LSBRACKET exp_math RSBRACKET array_size_non_empty
    (105) array_size -> . empty
    (113) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LSBRACKET resolved as shift
    LPAREN          shift and go to state 95
    DOT             shift and go to state 97
    LSBRACKET       shift and go to state 98
    MORETHAN        reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    MOREOREQUALTHAN reduce using rule 113 (empty -> .)
    LESSOREQUALTHAN reduce using rule 113 (empty -> .)
    DOUBLEEQUALS    reduce using rule 113 (empty -> .)
    NOTEQUAL        reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)

  ! LPAREN          [ reduce using rule 113 (empty -> .) ]
  ! DOT             [ reduce using rule 113 (empty -> .) ]
  ! LSBRACKET       [ reduce using rule 113 (empty -> .) ]

    name                           shift and go to state 114
    field                          shift and go to state 93
    array_size                     shift and go to state 94
    empty                          shift and go to state 96

state 92

    (92) param -> ID name .

    PLUS            reduce using rule 92 (param -> ID name .)
    MINUS           reduce using rule 92 (param -> ID name .)
    TIMES           reduce using rule 92 (param -> ID name .)
    DIVIDE          reduce using rule 92 (param -> ID name .)
    MORETHAN        reduce using rule 92 (param -> ID name .)
    LESSTHAN        reduce using rule 92 (param -> ID name .)
    MOREOREQUALTHAN reduce using rule 92 (param -> ID name .)
    LESSOREQUALTHAN reduce using rule 92 (param -> ID name .)
    DOUBLEEQUALS    reduce using rule 92 (param -> ID name .)
    NOTEQUAL        reduce using rule 92 (param -> ID name .)
    ID              reduce using rule 92 (param -> ID name .)
    LPAREN          reduce using rule 92 (param -> ID name .)
    DOT             reduce using rule 92 (param -> ID name .)
    LSBRACKET       reduce using rule 92 (param -> ID name .)
    COMMA           reduce using rule 92 (param -> ID name .)
    SEMICOLON       reduce using rule 92 (param -> ID name .)
    RPAREN          reduce using rule 92 (param -> ID name .)
    RSBRACKET       reduce using rule 92 (param -> ID name .)


state 93

    (95) name -> field .

    PLUS            reduce using rule 95 (name -> field .)
    MINUS           reduce using rule 95 (name -> field .)
    TIMES           reduce using rule 95 (name -> field .)
    DIVIDE          reduce using rule 95 (name -> field .)
    MORETHAN        reduce using rule 95 (name -> field .)
    LESSTHAN        reduce using rule 95 (name -> field .)
    MOREOREQUALTHAN reduce using rule 95 (name -> field .)
    LESSOREQUALTHAN reduce using rule 95 (name -> field .)
    DOUBLEEQUALS    reduce using rule 95 (name -> field .)
    NOTEQUAL        reduce using rule 95 (name -> field .)
    ID              reduce using rule 95 (name -> field .)
    LPAREN          reduce using rule 95 (name -> field .)
    DOT             reduce using rule 95 (name -> field .)
    LSBRACKET       reduce using rule 95 (name -> field .)
    COMMA           reduce using rule 95 (name -> field .)
    SEMICOLON       reduce using rule 95 (name -> field .)
    RPAREN          reduce using rule 95 (name -> field .)
    RSBRACKET       reduce using rule 95 (name -> field .)
    ASSIGNMENT      reduce using rule 95 (name -> field .)


state 94

    (96) name -> array_size . name_non_empty
    (99) name_non_empty -> . field
    (100) name_non_empty -> . array_size name_non_empty
    (101) name_non_empty -> . LPAREN params RPAREN name_non_empty
    (102) field -> . DOT ID name_non_empty
    (103) field -> . empty
    (104) array_size -> . LSBRACKET exp_math RSBRACKET array_size_non_empty
    (105) array_size -> . empty
    (113) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LSBRACKET resolved as shift
    LPAREN          shift and go to state 118
    DOT             shift and go to state 97
    LSBRACKET       shift and go to state 98
    PLUS            reduce using rule 113 (empty -> .)
    MINUS           reduce using rule 113 (empty -> .)
    TIMES           reduce using rule 113 (empty -> .)
    DIVIDE          reduce using rule 113 (empty -> .)
    MORETHAN        reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    MOREOREQUALTHAN reduce using rule 113 (empty -> .)
    LESSOREQUALTHAN reduce using rule 113 (empty -> .)
    DOUBLEEQUALS    reduce using rule 113 (empty -> .)
    NOTEQUAL        reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    RSBRACKET       reduce using rule 113 (empty -> .)
    ASSIGNMENT      reduce using rule 113 (empty -> .)

  ! LPAREN          [ reduce using rule 113 (empty -> .) ]
  ! DOT             [ reduce using rule 113 (empty -> .) ]
  ! LSBRACKET       [ reduce using rule 113 (empty -> .) ]

    array_size                     shift and go to state 115
    name_non_empty                 shift and go to state 116
    field                          shift and go to state 117
    empty                          shift and go to state 119

state 95

    (97) name -> LPAREN . params RPAREN name_non_empty
    (70) params -> . param param_list
    (71) params -> . empty
    (92) param -> . ID name
    (93) param -> . THIS field
    (94) param -> . const
    (113) empty -> .
    (108) const -> . NUMBER
    (109) const -> . STRING
    (110) const -> . CHARACTER
    (111) const -> . TRUE
    (112) const -> . FALSE

    ID              shift and go to state 65
    THIS            shift and go to state 71
    RPAREN          reduce using rule 113 (empty -> .)
    NUMBER          shift and go to state 74
    STRING          shift and go to state 75
    CHARACTER       shift and go to state 76
    TRUE            shift and go to state 77
    FALSE           shift and go to state 78

    params                         shift and go to state 120
    param                          shift and go to state 121
    empty                          shift and go to state 122
    const                          shift and go to state 72

state 96

    (98) name -> empty .
    (103) field -> empty .
    (105) array_size -> empty .

  ! reduce/reduce conflict for PLUS resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for MINUS resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for TIMES resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for MORETHAN resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for LESSTHAN resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for MOREOREQUALTHAN resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for LESSOREQUALTHAN resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for DOUBLEEQUALS resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for NOTEQUAL resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for ID resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for LPAREN resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for DOT resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for LSBRACKET resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for COMMA resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for RPAREN resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for RSBRACKET resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for ASSIGNMENT resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for LPAREN resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for DOT resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for LSBRACKET resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for PLUS resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for MINUS resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for TIMES resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for MORETHAN resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for LESSTHAN resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for MOREOREQUALTHAN resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for LESSOREQUALTHAN resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for DOUBLEEQUALS resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for NOTEQUAL resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for ID resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for COMMA resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for RPAREN resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for RSBRACKET resolved using rule 98 (name -> empty .)
  ! reduce/reduce conflict for ASSIGNMENT resolved using rule 98 (name -> empty .)
    PLUS            reduce using rule 98 (name -> empty .)
    MINUS           reduce using rule 98 (name -> empty .)
    TIMES           reduce using rule 98 (name -> empty .)
    DIVIDE          reduce using rule 98 (name -> empty .)
    MORETHAN        reduce using rule 98 (name -> empty .)
    LESSTHAN        reduce using rule 98 (name -> empty .)
    MOREOREQUALTHAN reduce using rule 98 (name -> empty .)
    LESSOREQUALTHAN reduce using rule 98 (name -> empty .)
    DOUBLEEQUALS    reduce using rule 98 (name -> empty .)
    NOTEQUAL        reduce using rule 98 (name -> empty .)
    ID              reduce using rule 98 (name -> empty .)
    LPAREN          reduce using rule 98 (name -> empty .)
    DOT             reduce using rule 98 (name -> empty .)
    LSBRACKET       reduce using rule 98 (name -> empty .)
    COMMA           reduce using rule 98 (name -> empty .)
    SEMICOLON       reduce using rule 98 (name -> empty .)
    RPAREN          reduce using rule 98 (name -> empty .)
    RSBRACKET       reduce using rule 98 (name -> empty .)
    ASSIGNMENT      reduce using rule 98 (name -> empty .)

  ! PLUS            [ reduce using rule 103 (field -> empty .) ]
  ! MINUS           [ reduce using rule 103 (field -> empty .) ]
  ! TIMES           [ reduce using rule 103 (field -> empty .) ]
  ! DIVIDE          [ reduce using rule 103 (field -> empty .) ]
  ! MORETHAN        [ reduce using rule 103 (field -> empty .) ]
  ! LESSTHAN        [ reduce using rule 103 (field -> empty .) ]
  ! MOREOREQUALTHAN [ reduce using rule 103 (field -> empty .) ]
  ! LESSOREQUALTHAN [ reduce using rule 103 (field -> empty .) ]
  ! DOUBLEEQUALS    [ reduce using rule 103 (field -> empty .) ]
  ! NOTEQUAL        [ reduce using rule 103 (field -> empty .) ]
  ! ID              [ reduce using rule 103 (field -> empty .) ]
  ! LPAREN          [ reduce using rule 103 (field -> empty .) ]
  ! DOT             [ reduce using rule 103 (field -> empty .) ]
  ! LSBRACKET       [ reduce using rule 103 (field -> empty .) ]
  ! COMMA           [ reduce using rule 103 (field -> empty .) ]
  ! SEMICOLON       [ reduce using rule 103 (field -> empty .) ]
  ! RPAREN          [ reduce using rule 103 (field -> empty .) ]
  ! RSBRACKET       [ reduce using rule 103 (field -> empty .) ]
  ! ASSIGNMENT      [ reduce using rule 103 (field -> empty .) ]
  ! LPAREN          [ reduce using rule 105 (array_size -> empty .) ]
  ! DOT             [ reduce using rule 105 (array_size -> empty .) ]
  ! LSBRACKET       [ reduce using rule 105 (array_size -> empty .) ]
  ! PLUS            [ reduce using rule 105 (array_size -> empty .) ]
  ! MINUS           [ reduce using rule 105 (array_size -> empty .) ]
  ! TIMES           [ reduce using rule 105 (array_size -> empty .) ]
  ! DIVIDE          [ reduce using rule 105 (array_size -> empty .) ]
  ! MORETHAN        [ reduce using rule 105 (array_size -> empty .) ]
  ! LESSTHAN        [ reduce using rule 105 (array_size -> empty .) ]
  ! MOREOREQUALTHAN [ reduce using rule 105 (array_size -> empty .) ]
  ! LESSOREQUALTHAN [ reduce using rule 105 (array_size -> empty .) ]
  ! DOUBLEEQUALS    [ reduce using rule 105 (array_size -> empty .) ]
  ! NOTEQUAL        [ reduce using rule 105 (array_size -> empty .) ]
  ! ID              [ reduce using rule 105 (array_size -> empty .) ]
  ! COMMA           [ reduce using rule 105 (array_size -> empty .) ]
  ! SEMICOLON       [ reduce using rule 105 (array_size -> empty .) ]
  ! RPAREN          [ reduce using rule 105 (array_size -> empty .) ]
  ! RSBRACKET       [ reduce using rule 105 (array_size -> empty .) ]
  ! ASSIGNMENT      [ reduce using rule 105 (array_size -> empty .) ]


state 97

    (102) field -> DOT . ID name_non_empty

    ID              shift and go to state 123


state 98

    (104) array_size -> LSBRACKET . exp_math RSBRACKET array_size_non_empty
    (80) exp_math -> . param op_math exp_math
    (81) exp_math -> . param
    (92) param -> . ID name
    (93) param -> . THIS field
    (94) param -> . const
    (108) const -> . NUMBER
    (109) const -> . STRING
    (110) const -> . CHARACTER
    (111) const -> . TRUE
    (112) const -> . FALSE

    ID              shift and go to state 65
    THIS            shift and go to state 71
    NUMBER          shift and go to state 74
    STRING          shift and go to state 75
    CHARACTER       shift and go to state 76
    TRUE            shift and go to state 77
    FALSE           shift and go to state 78

    exp_math                       shift and go to state 124
    param                          shift and go to state 67
    const                          shift and go to state 72

state 99

    (67) exp -> NEW type . name
    (76) exp_logic -> NEW type . name op_logic exp_logic_tail
    (95) name -> . field
    (96) name -> . array_size name_non_empty
    (97) name -> . LPAREN params RPAREN name_non_empty
    (98) name -> . empty
    (102) field -> . DOT ID name_non_empty
    (103) field -> . empty
    (104) array_size -> . LSBRACKET exp_math RSBRACKET array_size_non_empty
    (105) array_size -> . empty
    (113) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LSBRACKET resolved as shift
    LPAREN          shift and go to state 95
    DOT             shift and go to state 97
    LSBRACKET       shift and go to state 98
    MORETHAN        reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    MOREOREQUALTHAN reduce using rule 113 (empty -> .)
    LESSOREQUALTHAN reduce using rule 113 (empty -> .)
    DOUBLEEQUALS    reduce using rule 113 (empty -> .)
    NOTEQUAL        reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)

  ! LPAREN          [ reduce using rule 113 (empty -> .) ]
  ! DOT             [ reduce using rule 113 (empty -> .) ]
  ! LSBRACKET       [ reduce using rule 113 (empty -> .) ]

    name                           shift and go to state 125
    field                          shift and go to state 93
    array_size                     shift and go to state 94
    empty                          shift and go to state 96

state 100

    (80) exp_math -> param op_math . exp_math
    (80) exp_math -> . param op_math exp_math
    (81) exp_math -> . param
    (92) param -> . ID name
    (93) param -> . THIS field
    (94) param -> . const
    (108) const -> . NUMBER
    (109) const -> . STRING
    (110) const -> . CHARACTER
    (111) const -> . TRUE
    (112) const -> . FALSE

    ID              shift and go to state 65
    THIS            shift and go to state 71
    NUMBER          shift and go to state 74
    STRING          shift and go to state 75
    CHARACTER       shift and go to state 76
    TRUE            shift and go to state 77
    FALSE           shift and go to state 78

    param                          shift and go to state 67
    exp_math                       shift and go to state 126
    const                          shift and go to state 72

state 101

    (88) op_math -> PLUS .

    ID              reduce using rule 88 (op_math -> PLUS .)
    THIS            reduce using rule 88 (op_math -> PLUS .)
    NUMBER          reduce using rule 88 (op_math -> PLUS .)
    STRING          reduce using rule 88 (op_math -> PLUS .)
    CHARACTER       reduce using rule 88 (op_math -> PLUS .)
    TRUE            reduce using rule 88 (op_math -> PLUS .)
    FALSE           reduce using rule 88 (op_math -> PLUS .)


state 102

    (89) op_math -> MINUS .

    ID              reduce using rule 89 (op_math -> MINUS .)
    THIS            reduce using rule 89 (op_math -> MINUS .)
    NUMBER          reduce using rule 89 (op_math -> MINUS .)
    STRING          reduce using rule 89 (op_math -> MINUS .)
    CHARACTER       reduce using rule 89 (op_math -> MINUS .)
    TRUE            reduce using rule 89 (op_math -> MINUS .)
    FALSE           reduce using rule 89 (op_math -> MINUS .)


state 103

    (90) op_math -> TIMES .

    ID              reduce using rule 90 (op_math -> TIMES .)
    THIS            reduce using rule 90 (op_math -> TIMES .)
    NUMBER          reduce using rule 90 (op_math -> TIMES .)
    STRING          reduce using rule 90 (op_math -> TIMES .)
    CHARACTER       reduce using rule 90 (op_math -> TIMES .)
    TRUE            reduce using rule 90 (op_math -> TIMES .)
    FALSE           reduce using rule 90 (op_math -> TIMES .)


state 104

    (91) op_math -> DIVIDE .

    ID              reduce using rule 91 (op_math -> DIVIDE .)
    THIS            reduce using rule 91 (op_math -> DIVIDE .)
    NUMBER          reduce using rule 91 (op_math -> DIVIDE .)
    STRING          reduce using rule 91 (op_math -> DIVIDE .)
    CHARACTER       reduce using rule 91 (op_math -> DIVIDE .)
    TRUE            reduce using rule 91 (op_math -> DIVIDE .)
    FALSE           reduce using rule 91 (op_math -> DIVIDE .)


state 105

    (93) param -> THIS field .

    PLUS            reduce using rule 93 (param -> THIS field .)
    MINUS           reduce using rule 93 (param -> THIS field .)
    TIMES           reduce using rule 93 (param -> THIS field .)
    DIVIDE          reduce using rule 93 (param -> THIS field .)
    MORETHAN        reduce using rule 93 (param -> THIS field .)
    LESSTHAN        reduce using rule 93 (param -> THIS field .)
    MOREOREQUALTHAN reduce using rule 93 (param -> THIS field .)
    LESSOREQUALTHAN reduce using rule 93 (param -> THIS field .)
    DOUBLEEQUALS    reduce using rule 93 (param -> THIS field .)
    NOTEQUAL        reduce using rule 93 (param -> THIS field .)
    ID              reduce using rule 93 (param -> THIS field .)
    LPAREN          reduce using rule 93 (param -> THIS field .)
    DOT             reduce using rule 93 (param -> THIS field .)
    LSBRACKET       reduce using rule 93 (param -> THIS field .)
    COMMA           reduce using rule 93 (param -> THIS field .)
    SEMICOLON       reduce using rule 93 (param -> THIS field .)
    RPAREN          reduce using rule 93 (param -> THIS field .)
    RSBRACKET       reduce using rule 93 (param -> THIS field .)


state 106

    (103) field -> empty .

    PLUS            reduce using rule 103 (field -> empty .)
    MINUS           reduce using rule 103 (field -> empty .)
    TIMES           reduce using rule 103 (field -> empty .)
    DIVIDE          reduce using rule 103 (field -> empty .)
    MORETHAN        reduce using rule 103 (field -> empty .)
    LESSTHAN        reduce using rule 103 (field -> empty .)
    MOREOREQUALTHAN reduce using rule 103 (field -> empty .)
    LESSOREQUALTHAN reduce using rule 103 (field -> empty .)
    DOUBLEEQUALS    reduce using rule 103 (field -> empty .)
    NOTEQUAL        reduce using rule 103 (field -> empty .)
    ID              reduce using rule 103 (field -> empty .)
    LPAREN          reduce using rule 103 (field -> empty .)
    DOT             reduce using rule 103 (field -> empty .)
    LSBRACKET       reduce using rule 103 (field -> empty .)
    COMMA           reduce using rule 103 (field -> empty .)
    SEMICOLON       reduce using rule 103 (field -> empty .)
    RPAREN          reduce using rule 103 (field -> empty .)
    RSBRACKET       reduce using rule 103 (field -> empty .)


state 107

    (34) var_list -> COMMA var var_list .

    SEMICOLON       reduce using rule 34 (var_list -> COMMA var var_list .)


state 108

    (36) array -> LSBRACKET RSBRACKET array .

    ASSIGNMENT      reduce using rule 36 (array -> LSBRACKET RSBRACKET array .)
    COMMA           reduce using rule 36 (array -> LSBRACKET RSBRACKET array .)
    SEMICOLON       reduce using rule 36 (array -> LSBRACKET RSBRACKET array .)
    RPAREN          reduce using rule 36 (array -> LSBRACKET RSBRACKET array .)


state 109

    (38) method -> ID LPAREN argument . RPAREN bloc_com

    RPAREN          shift and go to state 127


state 110

    (39) argument -> type . var arg_list
    (31) var -> . ID array value

    ID              shift and go to state 47

    var                            shift and go to state 128

state 111

    (40) argument -> empty .

    RPAREN          reduce using rule 40 (argument -> empty .)


state 112

    (78) exp_logic_tail -> exp_math .

    ID              reduce using rule 78 (exp_logic_tail -> exp_math .)
    LPAREN          reduce using rule 78 (exp_logic_tail -> exp_math .)
    DOT             reduce using rule 78 (exp_logic_tail -> exp_math .)
    LSBRACKET       reduce using rule 78 (exp_logic_tail -> exp_math .)
    MORETHAN        reduce using rule 78 (exp_logic_tail -> exp_math .)
    LESSTHAN        reduce using rule 78 (exp_logic_tail -> exp_math .)
    MOREOREQUALTHAN reduce using rule 78 (exp_logic_tail -> exp_math .)
    LESSOREQUALTHAN reduce using rule 78 (exp_logic_tail -> exp_math .)
    DOUBLEEQUALS    reduce using rule 78 (exp_logic_tail -> exp_math .)
    NOTEQUAL        reduce using rule 78 (exp_logic_tail -> exp_math .)
    COMMA           reduce using rule 78 (exp_logic_tail -> exp_math .)
    SEMICOLON       reduce using rule 78 (exp_logic_tail -> exp_math .)
    RPAREN          reduce using rule 78 (exp_logic_tail -> exp_math .)


state 113

    (74) exp_logic -> exp_math op_logic exp_logic_tail .

    ID              reduce using rule 74 (exp_logic -> exp_math op_logic exp_logic_tail .)
    LPAREN          reduce using rule 74 (exp_logic -> exp_math op_logic exp_logic_tail .)
    DOT             reduce using rule 74 (exp_logic -> exp_math op_logic exp_logic_tail .)
    LSBRACKET       reduce using rule 74 (exp_logic -> exp_math op_logic exp_logic_tail .)
    MORETHAN        reduce using rule 74 (exp_logic -> exp_math op_logic exp_logic_tail .)
    LESSTHAN        reduce using rule 74 (exp_logic -> exp_math op_logic exp_logic_tail .)
    MOREOREQUALTHAN reduce using rule 74 (exp_logic -> exp_math op_logic exp_logic_tail .)
    LESSOREQUALTHAN reduce using rule 74 (exp_logic -> exp_math op_logic exp_logic_tail .)
    DOUBLEEQUALS    reduce using rule 74 (exp_logic -> exp_math op_logic exp_logic_tail .)
    NOTEQUAL        reduce using rule 74 (exp_logic -> exp_math op_logic exp_logic_tail .)
    COMMA           reduce using rule 74 (exp_logic -> exp_math op_logic exp_logic_tail .)
    SEMICOLON       reduce using rule 74 (exp_logic -> exp_math op_logic exp_logic_tail .)
    RPAREN          reduce using rule 74 (exp_logic -> exp_math op_logic exp_logic_tail .)


state 114

    (66) exp -> operator ID name .
    (75) exp_logic -> operator ID name . op_logic exp_logic_tail
    (82) op_logic -> . MORETHAN
    (83) op_logic -> . LESSTHAN
    (84) op_logic -> . MOREOREQUALTHAN
    (85) op_logic -> . LESSOREQUALTHAN
    (86) op_logic -> . DOUBLEEQUALS
    (87) op_logic -> . NOTEQUAL

  ! shift/reduce conflict for MORETHAN resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for MOREOREQUALTHAN resolved as shift
  ! shift/reduce conflict for LESSOREQUALTHAN resolved as shift
  ! shift/reduce conflict for DOUBLEEQUALS resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
    ID              reduce using rule 66 (exp -> operator ID name .)
    LPAREN          reduce using rule 66 (exp -> operator ID name .)
    DOT             reduce using rule 66 (exp -> operator ID name .)
    LSBRACKET       reduce using rule 66 (exp -> operator ID name .)
    COMMA           reduce using rule 66 (exp -> operator ID name .)
    SEMICOLON       reduce using rule 66 (exp -> operator ID name .)
    RPAREN          reduce using rule 66 (exp -> operator ID name .)
    MORETHAN        shift and go to state 85
    LESSTHAN        shift and go to state 86
    MOREOREQUALTHAN shift and go to state 87
    LESSOREQUALTHAN shift and go to state 88
    DOUBLEEQUALS    shift and go to state 89
    NOTEQUAL        shift and go to state 90

  ! MORETHAN        [ reduce using rule 66 (exp -> operator ID name .) ]
  ! LESSTHAN        [ reduce using rule 66 (exp -> operator ID name .) ]
  ! MOREOREQUALTHAN [ reduce using rule 66 (exp -> operator ID name .) ]
  ! LESSOREQUALTHAN [ reduce using rule 66 (exp -> operator ID name .) ]
  ! DOUBLEEQUALS    [ reduce using rule 66 (exp -> operator ID name .) ]
  ! NOTEQUAL        [ reduce using rule 66 (exp -> operator ID name .) ]

    op_logic                       shift and go to state 129

state 115

    (100) name_non_empty -> array_size . name_non_empty
    (99) name_non_empty -> . field
    (100) name_non_empty -> . array_size name_non_empty
    (101) name_non_empty -> . LPAREN params RPAREN name_non_empty
    (102) field -> . DOT ID name_non_empty
    (103) field -> . empty
    (104) array_size -> . LSBRACKET exp_math RSBRACKET array_size_non_empty
    (105) array_size -> . empty
    (113) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LSBRACKET resolved as shift
    LPAREN          shift and go to state 118
    DOT             shift and go to state 97
    LSBRACKET       shift and go to state 98
    PLUS            reduce using rule 113 (empty -> .)
    MINUS           reduce using rule 113 (empty -> .)
    TIMES           reduce using rule 113 (empty -> .)
    DIVIDE          reduce using rule 113 (empty -> .)
    MORETHAN        reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    MOREOREQUALTHAN reduce using rule 113 (empty -> .)
    LESSOREQUALTHAN reduce using rule 113 (empty -> .)
    DOUBLEEQUALS    reduce using rule 113 (empty -> .)
    NOTEQUAL        reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    RSBRACKET       reduce using rule 113 (empty -> .)
    ASSIGNMENT      reduce using rule 113 (empty -> .)

  ! LPAREN          [ reduce using rule 113 (empty -> .) ]
  ! DOT             [ reduce using rule 113 (empty -> .) ]
  ! LSBRACKET       [ reduce using rule 113 (empty -> .) ]

    array_size                     shift and go to state 115
    name_non_empty                 shift and go to state 130
    field                          shift and go to state 117
    empty                          shift and go to state 119

state 116

    (96) name -> array_size name_non_empty .

    PLUS            reduce using rule 96 (name -> array_size name_non_empty .)
    MINUS           reduce using rule 96 (name -> array_size name_non_empty .)
    TIMES           reduce using rule 96 (name -> array_size name_non_empty .)
    DIVIDE          reduce using rule 96 (name -> array_size name_non_empty .)
    MORETHAN        reduce using rule 96 (name -> array_size name_non_empty .)
    LESSTHAN        reduce using rule 96 (name -> array_size name_non_empty .)
    MOREOREQUALTHAN reduce using rule 96 (name -> array_size name_non_empty .)
    LESSOREQUALTHAN reduce using rule 96 (name -> array_size name_non_empty .)
    DOUBLEEQUALS    reduce using rule 96 (name -> array_size name_non_empty .)
    NOTEQUAL        reduce using rule 96 (name -> array_size name_non_empty .)
    ID              reduce using rule 96 (name -> array_size name_non_empty .)
    LPAREN          reduce using rule 96 (name -> array_size name_non_empty .)
    DOT             reduce using rule 96 (name -> array_size name_non_empty .)
    LSBRACKET       reduce using rule 96 (name -> array_size name_non_empty .)
    COMMA           reduce using rule 96 (name -> array_size name_non_empty .)
    SEMICOLON       reduce using rule 96 (name -> array_size name_non_empty .)
    RPAREN          reduce using rule 96 (name -> array_size name_non_empty .)
    RSBRACKET       reduce using rule 96 (name -> array_size name_non_empty .)
    ASSIGNMENT      reduce using rule 96 (name -> array_size name_non_empty .)


state 117

    (99) name_non_empty -> field .

    PLUS            reduce using rule 99 (name_non_empty -> field .)
    MINUS           reduce using rule 99 (name_non_empty -> field .)
    TIMES           reduce using rule 99 (name_non_empty -> field .)
    DIVIDE          reduce using rule 99 (name_non_empty -> field .)
    MORETHAN        reduce using rule 99 (name_non_empty -> field .)
    LESSTHAN        reduce using rule 99 (name_non_empty -> field .)
    MOREOREQUALTHAN reduce using rule 99 (name_non_empty -> field .)
    LESSOREQUALTHAN reduce using rule 99 (name_non_empty -> field .)
    DOUBLEEQUALS    reduce using rule 99 (name_non_empty -> field .)
    NOTEQUAL        reduce using rule 99 (name_non_empty -> field .)
    ID              reduce using rule 99 (name_non_empty -> field .)
    LPAREN          reduce using rule 99 (name_non_empty -> field .)
    DOT             reduce using rule 99 (name_non_empty -> field .)
    LSBRACKET       reduce using rule 99 (name_non_empty -> field .)
    COMMA           reduce using rule 99 (name_non_empty -> field .)
    SEMICOLON       reduce using rule 99 (name_non_empty -> field .)
    RPAREN          reduce using rule 99 (name_non_empty -> field .)
    RSBRACKET       reduce using rule 99 (name_non_empty -> field .)
    ASSIGNMENT      reduce using rule 99 (name_non_empty -> field .)


state 118

    (101) name_non_empty -> LPAREN . params RPAREN name_non_empty
    (70) params -> . param param_list
    (71) params -> . empty
    (92) param -> . ID name
    (93) param -> . THIS field
    (94) param -> . const
    (113) empty -> .
    (108) const -> . NUMBER
    (109) const -> . STRING
    (110) const -> . CHARACTER
    (111) const -> . TRUE
    (112) const -> . FALSE

    ID              shift and go to state 65
    THIS            shift and go to state 71
    RPAREN          reduce using rule 113 (empty -> .)
    NUMBER          shift and go to state 74
    STRING          shift and go to state 75
    CHARACTER       shift and go to state 76
    TRUE            shift and go to state 77
    FALSE           shift and go to state 78

    params                         shift and go to state 131
    param                          shift and go to state 121
    empty                          shift and go to state 122
    const                          shift and go to state 72

state 119

    (103) field -> empty .
    (105) array_size -> empty .

  ! reduce/reduce conflict for LPAREN resolved using rule 103 (field -> empty .)
  ! reduce/reduce conflict for DOT resolved using rule 103 (field -> empty .)
  ! reduce/reduce conflict for LSBRACKET resolved using rule 103 (field -> empty .)
  ! reduce/reduce conflict for PLUS resolved using rule 103 (field -> empty .)
  ! reduce/reduce conflict for MINUS resolved using rule 103 (field -> empty .)
  ! reduce/reduce conflict for TIMES resolved using rule 103 (field -> empty .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 103 (field -> empty .)
  ! reduce/reduce conflict for MORETHAN resolved using rule 103 (field -> empty .)
  ! reduce/reduce conflict for LESSTHAN resolved using rule 103 (field -> empty .)
  ! reduce/reduce conflict for MOREOREQUALTHAN resolved using rule 103 (field -> empty .)
  ! reduce/reduce conflict for LESSOREQUALTHAN resolved using rule 103 (field -> empty .)
  ! reduce/reduce conflict for DOUBLEEQUALS resolved using rule 103 (field -> empty .)
  ! reduce/reduce conflict for NOTEQUAL resolved using rule 103 (field -> empty .)
  ! reduce/reduce conflict for ID resolved using rule 103 (field -> empty .)
  ! reduce/reduce conflict for COMMA resolved using rule 103 (field -> empty .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 103 (field -> empty .)
  ! reduce/reduce conflict for RPAREN resolved using rule 103 (field -> empty .)
  ! reduce/reduce conflict for RSBRACKET resolved using rule 103 (field -> empty .)
  ! reduce/reduce conflict for ASSIGNMENT resolved using rule 103 (field -> empty .)
    PLUS            reduce using rule 103 (field -> empty .)
    MINUS           reduce using rule 103 (field -> empty .)
    TIMES           reduce using rule 103 (field -> empty .)
    DIVIDE          reduce using rule 103 (field -> empty .)
    MORETHAN        reduce using rule 103 (field -> empty .)
    LESSTHAN        reduce using rule 103 (field -> empty .)
    MOREOREQUALTHAN reduce using rule 103 (field -> empty .)
    LESSOREQUALTHAN reduce using rule 103 (field -> empty .)
    DOUBLEEQUALS    reduce using rule 103 (field -> empty .)
    NOTEQUAL        reduce using rule 103 (field -> empty .)
    ID              reduce using rule 103 (field -> empty .)
    LPAREN          reduce using rule 103 (field -> empty .)
    DOT             reduce using rule 103 (field -> empty .)
    LSBRACKET       reduce using rule 103 (field -> empty .)
    COMMA           reduce using rule 103 (field -> empty .)
    SEMICOLON       reduce using rule 103 (field -> empty .)
    RPAREN          reduce using rule 103 (field -> empty .)
    RSBRACKET       reduce using rule 103 (field -> empty .)
    ASSIGNMENT      reduce using rule 103 (field -> empty .)

  ! LPAREN          [ reduce using rule 105 (array_size -> empty .) ]
  ! DOT             [ reduce using rule 105 (array_size -> empty .) ]
  ! LSBRACKET       [ reduce using rule 105 (array_size -> empty .) ]
  ! PLUS            [ reduce using rule 105 (array_size -> empty .) ]
  ! MINUS           [ reduce using rule 105 (array_size -> empty .) ]
  ! TIMES           [ reduce using rule 105 (array_size -> empty .) ]
  ! DIVIDE          [ reduce using rule 105 (array_size -> empty .) ]
  ! MORETHAN        [ reduce using rule 105 (array_size -> empty .) ]
  ! LESSTHAN        [ reduce using rule 105 (array_size -> empty .) ]
  ! MOREOREQUALTHAN [ reduce using rule 105 (array_size -> empty .) ]
  ! LESSOREQUALTHAN [ reduce using rule 105 (array_size -> empty .) ]
  ! DOUBLEEQUALS    [ reduce using rule 105 (array_size -> empty .) ]
  ! NOTEQUAL        [ reduce using rule 105 (array_size -> empty .) ]
  ! ID              [ reduce using rule 105 (array_size -> empty .) ]
  ! COMMA           [ reduce using rule 105 (array_size -> empty .) ]
  ! SEMICOLON       [ reduce using rule 105 (array_size -> empty .) ]
  ! RPAREN          [ reduce using rule 105 (array_size -> empty .) ]
  ! RSBRACKET       [ reduce using rule 105 (array_size -> empty .) ]
  ! ASSIGNMENT      [ reduce using rule 105 (array_size -> empty .) ]


state 120

    (97) name -> LPAREN params . RPAREN name_non_empty

    RPAREN          shift and go to state 132


state 121

    (70) params -> param . param_list
    (72) param_list -> . COMMA param param_list
    (73) param_list -> . empty
    (113) empty -> .

    COMMA           shift and go to state 134
    RPAREN          reduce using rule 113 (empty -> .)

    param_list                     shift and go to state 133
    empty                          shift and go to state 135

state 122

    (71) params -> empty .

    RPAREN          reduce using rule 71 (params -> empty .)


state 123

    (102) field -> DOT ID . name_non_empty
    (99) name_non_empty -> . field
    (100) name_non_empty -> . array_size name_non_empty
    (101) name_non_empty -> . LPAREN params RPAREN name_non_empty
    (102) field -> . DOT ID name_non_empty
    (103) field -> . empty
    (104) array_size -> . LSBRACKET exp_math RSBRACKET array_size_non_empty
    (105) array_size -> . empty
    (113) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LSBRACKET resolved as shift
    LPAREN          shift and go to state 118
    DOT             shift and go to state 97
    LSBRACKET       shift and go to state 98
    PLUS            reduce using rule 113 (empty -> .)
    MINUS           reduce using rule 113 (empty -> .)
    TIMES           reduce using rule 113 (empty -> .)
    DIVIDE          reduce using rule 113 (empty -> .)
    MORETHAN        reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    MOREOREQUALTHAN reduce using rule 113 (empty -> .)
    LESSOREQUALTHAN reduce using rule 113 (empty -> .)
    DOUBLEEQUALS    reduce using rule 113 (empty -> .)
    NOTEQUAL        reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    RSBRACKET       reduce using rule 113 (empty -> .)
    ASSIGNMENT      reduce using rule 113 (empty -> .)

  ! LPAREN          [ reduce using rule 113 (empty -> .) ]
  ! DOT             [ reduce using rule 113 (empty -> .) ]
  ! LSBRACKET       [ reduce using rule 113 (empty -> .) ]

    name_non_empty                 shift and go to state 136
    field                          shift and go to state 117
    array_size                     shift and go to state 115
    empty                          shift and go to state 119

state 124

    (104) array_size -> LSBRACKET exp_math . RSBRACKET array_size_non_empty

    RSBRACKET       shift and go to state 137


state 125

    (67) exp -> NEW type name .
    (76) exp_logic -> NEW type name . op_logic exp_logic_tail
    (82) op_logic -> . MORETHAN
    (83) op_logic -> . LESSTHAN
    (84) op_logic -> . MOREOREQUALTHAN
    (85) op_logic -> . LESSOREQUALTHAN
    (86) op_logic -> . DOUBLEEQUALS
    (87) op_logic -> . NOTEQUAL

  ! shift/reduce conflict for MORETHAN resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for MOREOREQUALTHAN resolved as shift
  ! shift/reduce conflict for LESSOREQUALTHAN resolved as shift
  ! shift/reduce conflict for DOUBLEEQUALS resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
    ID              reduce using rule 67 (exp -> NEW type name .)
    LPAREN          reduce using rule 67 (exp -> NEW type name .)
    DOT             reduce using rule 67 (exp -> NEW type name .)
    LSBRACKET       reduce using rule 67 (exp -> NEW type name .)
    COMMA           reduce using rule 67 (exp -> NEW type name .)
    SEMICOLON       reduce using rule 67 (exp -> NEW type name .)
    RPAREN          reduce using rule 67 (exp -> NEW type name .)
    MORETHAN        shift and go to state 85
    LESSTHAN        shift and go to state 86
    MOREOREQUALTHAN shift and go to state 87
    LESSOREQUALTHAN shift and go to state 88
    DOUBLEEQUALS    shift and go to state 89
    NOTEQUAL        shift and go to state 90

  ! MORETHAN        [ reduce using rule 67 (exp -> NEW type name .) ]
  ! LESSTHAN        [ reduce using rule 67 (exp -> NEW type name .) ]
  ! MOREOREQUALTHAN [ reduce using rule 67 (exp -> NEW type name .) ]
  ! LESSOREQUALTHAN [ reduce using rule 67 (exp -> NEW type name .) ]
  ! DOUBLEEQUALS    [ reduce using rule 67 (exp -> NEW type name .) ]
  ! NOTEQUAL        [ reduce using rule 67 (exp -> NEW type name .) ]

    op_logic                       shift and go to state 138

state 126

    (80) exp_math -> param op_math exp_math .

    MORETHAN        reduce using rule 80 (exp_math -> param op_math exp_math .)
    LESSTHAN        reduce using rule 80 (exp_math -> param op_math exp_math .)
    MOREOREQUALTHAN reduce using rule 80 (exp_math -> param op_math exp_math .)
    LESSOREQUALTHAN reduce using rule 80 (exp_math -> param op_math exp_math .)
    DOUBLEEQUALS    reduce using rule 80 (exp_math -> param op_math exp_math .)
    NOTEQUAL        reduce using rule 80 (exp_math -> param op_math exp_math .)
    ID              reduce using rule 80 (exp_math -> param op_math exp_math .)
    LPAREN          reduce using rule 80 (exp_math -> param op_math exp_math .)
    DOT             reduce using rule 80 (exp_math -> param op_math exp_math .)
    LSBRACKET       reduce using rule 80 (exp_math -> param op_math exp_math .)
    COMMA           reduce using rule 80 (exp_math -> param op_math exp_math .)
    SEMICOLON       reduce using rule 80 (exp_math -> param op_math exp_math .)
    RPAREN          reduce using rule 80 (exp_math -> param op_math exp_math .)
    RSBRACKET       reduce using rule 80 (exp_math -> param op_math exp_math .)


state 127

    (38) method -> ID LPAREN argument RPAREN . bloc_com
    (43) bloc_com -> . LCURLYBRACE com_list RCURLYBRACE

    LCURLYBRACE     shift and go to state 140

    bloc_com                       shift and go to state 139

state 128

    (39) argument -> type var . arg_list
    (41) arg_list -> . COMMA argument
    (42) arg_list -> . empty
    (113) empty -> .

    COMMA           shift and go to state 142
    RPAREN          reduce using rule 113 (empty -> .)

    arg_list                       shift and go to state 141
    empty                          shift and go to state 143

state 129

    (75) exp_logic -> operator ID name op_logic . exp_logic_tail
    (78) exp_logic_tail -> . exp_math
    (79) exp_logic_tail -> . empty
    (80) exp_math -> . param op_math exp_math
    (81) exp_math -> . param
    (113) empty -> .
    (92) param -> . ID name
    (93) param -> . THIS field
    (94) param -> . const
    (108) const -> . NUMBER
    (109) const -> . STRING
    (110) const -> . CHARACTER
    (111) const -> . TRUE
    (112) const -> . FALSE

  ! shift/reduce conflict for ID resolved as shift
    LPAREN          reduce using rule 113 (empty -> .)
    DOT             reduce using rule 113 (empty -> .)
    LSBRACKET       reduce using rule 113 (empty -> .)
    MORETHAN        reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    MOREOREQUALTHAN reduce using rule 113 (empty -> .)
    LESSOREQUALTHAN reduce using rule 113 (empty -> .)
    DOUBLEEQUALS    reduce using rule 113 (empty -> .)
    NOTEQUAL        reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    ID              shift and go to state 65
    THIS            shift and go to state 71
    NUMBER          shift and go to state 74
    STRING          shift and go to state 75
    CHARACTER       shift and go to state 76
    TRUE            shift and go to state 77
    FALSE           shift and go to state 78

  ! ID              [ reduce using rule 113 (empty -> .) ]

    exp_logic_tail                 shift and go to state 144
    exp_math                       shift and go to state 112
    empty                          shift and go to state 73
    param                          shift and go to state 67
    const                          shift and go to state 72

state 130

    (100) name_non_empty -> array_size name_non_empty .

    PLUS            reduce using rule 100 (name_non_empty -> array_size name_non_empty .)
    MINUS           reduce using rule 100 (name_non_empty -> array_size name_non_empty .)
    TIMES           reduce using rule 100 (name_non_empty -> array_size name_non_empty .)
    DIVIDE          reduce using rule 100 (name_non_empty -> array_size name_non_empty .)
    MORETHAN        reduce using rule 100 (name_non_empty -> array_size name_non_empty .)
    LESSTHAN        reduce using rule 100 (name_non_empty -> array_size name_non_empty .)
    MOREOREQUALTHAN reduce using rule 100 (name_non_empty -> array_size name_non_empty .)
    LESSOREQUALTHAN reduce using rule 100 (name_non_empty -> array_size name_non_empty .)
    DOUBLEEQUALS    reduce using rule 100 (name_non_empty -> array_size name_non_empty .)
    NOTEQUAL        reduce using rule 100 (name_non_empty -> array_size name_non_empty .)
    ID              reduce using rule 100 (name_non_empty -> array_size name_non_empty .)
    LPAREN          reduce using rule 100 (name_non_empty -> array_size name_non_empty .)
    DOT             reduce using rule 100 (name_non_empty -> array_size name_non_empty .)
    LSBRACKET       reduce using rule 100 (name_non_empty -> array_size name_non_empty .)
    COMMA           reduce using rule 100 (name_non_empty -> array_size name_non_empty .)
    SEMICOLON       reduce using rule 100 (name_non_empty -> array_size name_non_empty .)
    RPAREN          reduce using rule 100 (name_non_empty -> array_size name_non_empty .)
    RSBRACKET       reduce using rule 100 (name_non_empty -> array_size name_non_empty .)
    ASSIGNMENT      reduce using rule 100 (name_non_empty -> array_size name_non_empty .)


state 131

    (101) name_non_empty -> LPAREN params . RPAREN name_non_empty

    RPAREN          shift and go to state 145


state 132

    (97) name -> LPAREN params RPAREN . name_non_empty
    (99) name_non_empty -> . field
    (100) name_non_empty -> . array_size name_non_empty
    (101) name_non_empty -> . LPAREN params RPAREN name_non_empty
    (102) field -> . DOT ID name_non_empty
    (103) field -> . empty
    (104) array_size -> . LSBRACKET exp_math RSBRACKET array_size_non_empty
    (105) array_size -> . empty
    (113) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LSBRACKET resolved as shift
    LPAREN          shift and go to state 118
    DOT             shift and go to state 97
    LSBRACKET       shift and go to state 98
    PLUS            reduce using rule 113 (empty -> .)
    MINUS           reduce using rule 113 (empty -> .)
    TIMES           reduce using rule 113 (empty -> .)
    DIVIDE          reduce using rule 113 (empty -> .)
    MORETHAN        reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    MOREOREQUALTHAN reduce using rule 113 (empty -> .)
    LESSOREQUALTHAN reduce using rule 113 (empty -> .)
    DOUBLEEQUALS    reduce using rule 113 (empty -> .)
    NOTEQUAL        reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    RSBRACKET       reduce using rule 113 (empty -> .)
    ASSIGNMENT      reduce using rule 113 (empty -> .)

  ! LPAREN          [ reduce using rule 113 (empty -> .) ]
  ! DOT             [ reduce using rule 113 (empty -> .) ]
  ! LSBRACKET       [ reduce using rule 113 (empty -> .) ]

    name_non_empty                 shift and go to state 146
    field                          shift and go to state 117
    array_size                     shift and go to state 115
    empty                          shift and go to state 119

state 133

    (70) params -> param param_list .

    RPAREN          reduce using rule 70 (params -> param param_list .)


state 134

    (72) param_list -> COMMA . param param_list
    (92) param -> . ID name
    (93) param -> . THIS field
    (94) param -> . const
    (108) const -> . NUMBER
    (109) const -> . STRING
    (110) const -> . CHARACTER
    (111) const -> . TRUE
    (112) const -> . FALSE

    ID              shift and go to state 65
    THIS            shift and go to state 71
    NUMBER          shift and go to state 74
    STRING          shift and go to state 75
    CHARACTER       shift and go to state 76
    TRUE            shift and go to state 77
    FALSE           shift and go to state 78

    param                          shift and go to state 147
    const                          shift and go to state 72

state 135

    (73) param_list -> empty .

    RPAREN          reduce using rule 73 (param_list -> empty .)


state 136

    (102) field -> DOT ID name_non_empty .

    PLUS            reduce using rule 102 (field -> DOT ID name_non_empty .)
    MINUS           reduce using rule 102 (field -> DOT ID name_non_empty .)
    TIMES           reduce using rule 102 (field -> DOT ID name_non_empty .)
    DIVIDE          reduce using rule 102 (field -> DOT ID name_non_empty .)
    MORETHAN        reduce using rule 102 (field -> DOT ID name_non_empty .)
    LESSTHAN        reduce using rule 102 (field -> DOT ID name_non_empty .)
    MOREOREQUALTHAN reduce using rule 102 (field -> DOT ID name_non_empty .)
    LESSOREQUALTHAN reduce using rule 102 (field -> DOT ID name_non_empty .)
    DOUBLEEQUALS    reduce using rule 102 (field -> DOT ID name_non_empty .)
    NOTEQUAL        reduce using rule 102 (field -> DOT ID name_non_empty .)
    ID              reduce using rule 102 (field -> DOT ID name_non_empty .)
    LPAREN          reduce using rule 102 (field -> DOT ID name_non_empty .)
    DOT             reduce using rule 102 (field -> DOT ID name_non_empty .)
    LSBRACKET       reduce using rule 102 (field -> DOT ID name_non_empty .)
    COMMA           reduce using rule 102 (field -> DOT ID name_non_empty .)
    SEMICOLON       reduce using rule 102 (field -> DOT ID name_non_empty .)
    RPAREN          reduce using rule 102 (field -> DOT ID name_non_empty .)
    RSBRACKET       reduce using rule 102 (field -> DOT ID name_non_empty .)
    ASSIGNMENT      reduce using rule 102 (field -> DOT ID name_non_empty .)


state 137

    (104) array_size -> LSBRACKET exp_math RSBRACKET . array_size_non_empty
    (106) array_size_non_empty -> . LSBRACKET exp_math RSBRACKET array_size_non_empty
    (107) array_size_non_empty -> . empty
    (113) empty -> .

  ! shift/reduce conflict for LSBRACKET resolved as shift
    LSBRACKET       shift and go to state 148
    LPAREN          reduce using rule 113 (empty -> .)
    DOT             reduce using rule 113 (empty -> .)
    PLUS            reduce using rule 113 (empty -> .)
    MINUS           reduce using rule 113 (empty -> .)
    TIMES           reduce using rule 113 (empty -> .)
    DIVIDE          reduce using rule 113 (empty -> .)
    MORETHAN        reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    MOREOREQUALTHAN reduce using rule 113 (empty -> .)
    LESSOREQUALTHAN reduce using rule 113 (empty -> .)
    DOUBLEEQUALS    reduce using rule 113 (empty -> .)
    NOTEQUAL        reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    RSBRACKET       reduce using rule 113 (empty -> .)
    ASSIGNMENT      reduce using rule 113 (empty -> .)

  ! LSBRACKET       [ reduce using rule 113 (empty -> .) ]

    array_size_non_empty           shift and go to state 149
    empty                          shift and go to state 150

state 138

    (76) exp_logic -> NEW type name op_logic . exp_logic_tail
    (78) exp_logic_tail -> . exp_math
    (79) exp_logic_tail -> . empty
    (80) exp_math -> . param op_math exp_math
    (81) exp_math -> . param
    (113) empty -> .
    (92) param -> . ID name
    (93) param -> . THIS field
    (94) param -> . const
    (108) const -> . NUMBER
    (109) const -> . STRING
    (110) const -> . CHARACTER
    (111) const -> . TRUE
    (112) const -> . FALSE

  ! shift/reduce conflict for ID resolved as shift
    LPAREN          reduce using rule 113 (empty -> .)
    DOT             reduce using rule 113 (empty -> .)
    LSBRACKET       reduce using rule 113 (empty -> .)
    MORETHAN        reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    MOREOREQUALTHAN reduce using rule 113 (empty -> .)
    LESSOREQUALTHAN reduce using rule 113 (empty -> .)
    DOUBLEEQUALS    reduce using rule 113 (empty -> .)
    NOTEQUAL        reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    ID              shift and go to state 65
    THIS            shift and go to state 71
    NUMBER          shift and go to state 74
    STRING          shift and go to state 75
    CHARACTER       shift and go to state 76
    TRUE            shift and go to state 77
    FALSE           shift and go to state 78

  ! ID              [ reduce using rule 113 (empty -> .) ]

    exp_logic_tail                 shift and go to state 151
    exp_math                       shift and go to state 112
    empty                          shift and go to state 73
    param                          shift and go to state 67
    const                          shift and go to state 72

state 139

    (38) method -> ID LPAREN argument RPAREN bloc_com .

    SEMICOLON       reduce using rule 38 (method -> ID LPAREN argument RPAREN bloc_com .)


state 140

    (43) bloc_com -> LCURLYBRACE . com_list RCURLYBRACE
    (46) com_list -> . command com_list
    (47) com_list -> . empty
    (48) command -> . atrib SEMICOLON
    (49) command -> . WHILE LPAREN exp_logic RPAREN bloc
    (50) command -> . DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON
    (51) command -> . IF LPAREN exp_logic RPAREN bloc else
    (52) command -> . FOR LPAREN for_exp RPAREN bloc
    (53) command -> . SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE
    (54) command -> . BREAK SEMICOLON
    (55) command -> . CONTINUE SEMICOLON
    (56) command -> . RETURN exp SEMICOLON
    (113) empty -> .
    (57) atrib -> . ID name ASSIGNMENT exp

    WHILE           shift and go to state 156
    DO              shift and go to state 157
    IF              shift and go to state 158
    FOR             shift and go to state 159
    SWITCH          shift and go to state 160
    BREAK           shift and go to state 162
    CONTINUE        shift and go to state 163
    RETURN          shift and go to state 164
    RCURLYBRACE     reduce using rule 113 (empty -> .)
    ID              shift and go to state 161

    com_list                       shift and go to state 152
    command                        shift and go to state 153
    empty                          shift and go to state 154
    atrib                          shift and go to state 155

state 141

    (39) argument -> type var arg_list .

    RPAREN          reduce using rule 39 (argument -> type var arg_list .)


state 142

    (41) arg_list -> COMMA . argument
    (39) argument -> . type var arg_list
    (40) argument -> . empty
    (25) type -> . INT
    (26) type -> . FLOAT
    (27) type -> . DOUBLE
    (28) type -> . CHAR
    (29) type -> . VOID
    (30) type -> . ID value
    (113) empty -> .

    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    DOUBLE          shift and go to state 41
    CHAR            shift and go to state 42
    VOID            shift and go to state 43
    ID              shift and go to state 44
    RPAREN          reduce using rule 113 (empty -> .)

    argument                       shift and go to state 165
    type                           shift and go to state 110
    empty                          shift and go to state 111

state 143

    (42) arg_list -> empty .

    RPAREN          reduce using rule 42 (arg_list -> empty .)


state 144

    (75) exp_logic -> operator ID name op_logic exp_logic_tail .

    ID              reduce using rule 75 (exp_logic -> operator ID name op_logic exp_logic_tail .)
    LPAREN          reduce using rule 75 (exp_logic -> operator ID name op_logic exp_logic_tail .)
    DOT             reduce using rule 75 (exp_logic -> operator ID name op_logic exp_logic_tail .)
    LSBRACKET       reduce using rule 75 (exp_logic -> operator ID name op_logic exp_logic_tail .)
    MORETHAN        reduce using rule 75 (exp_logic -> operator ID name op_logic exp_logic_tail .)
    LESSTHAN        reduce using rule 75 (exp_logic -> operator ID name op_logic exp_logic_tail .)
    MOREOREQUALTHAN reduce using rule 75 (exp_logic -> operator ID name op_logic exp_logic_tail .)
    LESSOREQUALTHAN reduce using rule 75 (exp_logic -> operator ID name op_logic exp_logic_tail .)
    DOUBLEEQUALS    reduce using rule 75 (exp_logic -> operator ID name op_logic exp_logic_tail .)
    NOTEQUAL        reduce using rule 75 (exp_logic -> operator ID name op_logic exp_logic_tail .)
    COMMA           reduce using rule 75 (exp_logic -> operator ID name op_logic exp_logic_tail .)
    SEMICOLON       reduce using rule 75 (exp_logic -> operator ID name op_logic exp_logic_tail .)
    RPAREN          reduce using rule 75 (exp_logic -> operator ID name op_logic exp_logic_tail .)


state 145

    (101) name_non_empty -> LPAREN params RPAREN . name_non_empty
    (99) name_non_empty -> . field
    (100) name_non_empty -> . array_size name_non_empty
    (101) name_non_empty -> . LPAREN params RPAREN name_non_empty
    (102) field -> . DOT ID name_non_empty
    (103) field -> . empty
    (104) array_size -> . LSBRACKET exp_math RSBRACKET array_size_non_empty
    (105) array_size -> . empty
    (113) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LSBRACKET resolved as shift
    LPAREN          shift and go to state 118
    DOT             shift and go to state 97
    LSBRACKET       shift and go to state 98
    PLUS            reduce using rule 113 (empty -> .)
    MINUS           reduce using rule 113 (empty -> .)
    TIMES           reduce using rule 113 (empty -> .)
    DIVIDE          reduce using rule 113 (empty -> .)
    MORETHAN        reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    MOREOREQUALTHAN reduce using rule 113 (empty -> .)
    LESSOREQUALTHAN reduce using rule 113 (empty -> .)
    DOUBLEEQUALS    reduce using rule 113 (empty -> .)
    NOTEQUAL        reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    RSBRACKET       reduce using rule 113 (empty -> .)
    ASSIGNMENT      reduce using rule 113 (empty -> .)

  ! LPAREN          [ reduce using rule 113 (empty -> .) ]
  ! DOT             [ reduce using rule 113 (empty -> .) ]
  ! LSBRACKET       [ reduce using rule 113 (empty -> .) ]

    name_non_empty                 shift and go to state 166
    field                          shift and go to state 117
    array_size                     shift and go to state 115
    empty                          shift and go to state 119

state 146

    (97) name -> LPAREN params RPAREN name_non_empty .

    PLUS            reduce using rule 97 (name -> LPAREN params RPAREN name_non_empty .)
    MINUS           reduce using rule 97 (name -> LPAREN params RPAREN name_non_empty .)
    TIMES           reduce using rule 97 (name -> LPAREN params RPAREN name_non_empty .)
    DIVIDE          reduce using rule 97 (name -> LPAREN params RPAREN name_non_empty .)
    MORETHAN        reduce using rule 97 (name -> LPAREN params RPAREN name_non_empty .)
    LESSTHAN        reduce using rule 97 (name -> LPAREN params RPAREN name_non_empty .)
    MOREOREQUALTHAN reduce using rule 97 (name -> LPAREN params RPAREN name_non_empty .)
    LESSOREQUALTHAN reduce using rule 97 (name -> LPAREN params RPAREN name_non_empty .)
    DOUBLEEQUALS    reduce using rule 97 (name -> LPAREN params RPAREN name_non_empty .)
    NOTEQUAL        reduce using rule 97 (name -> LPAREN params RPAREN name_non_empty .)
    ID              reduce using rule 97 (name -> LPAREN params RPAREN name_non_empty .)
    LPAREN          reduce using rule 97 (name -> LPAREN params RPAREN name_non_empty .)
    DOT             reduce using rule 97 (name -> LPAREN params RPAREN name_non_empty .)
    LSBRACKET       reduce using rule 97 (name -> LPAREN params RPAREN name_non_empty .)
    COMMA           reduce using rule 97 (name -> LPAREN params RPAREN name_non_empty .)
    SEMICOLON       reduce using rule 97 (name -> LPAREN params RPAREN name_non_empty .)
    RPAREN          reduce using rule 97 (name -> LPAREN params RPAREN name_non_empty .)
    RSBRACKET       reduce using rule 97 (name -> LPAREN params RPAREN name_non_empty .)
    ASSIGNMENT      reduce using rule 97 (name -> LPAREN params RPAREN name_non_empty .)


state 147

    (72) param_list -> COMMA param . param_list
    (72) param_list -> . COMMA param param_list
    (73) param_list -> . empty
    (113) empty -> .

    COMMA           shift and go to state 134
    RPAREN          reduce using rule 113 (empty -> .)

    param_list                     shift and go to state 167
    empty                          shift and go to state 135

state 148

    (106) array_size_non_empty -> LSBRACKET . exp_math RSBRACKET array_size_non_empty
    (80) exp_math -> . param op_math exp_math
    (81) exp_math -> . param
    (92) param -> . ID name
    (93) param -> . THIS field
    (94) param -> . const
    (108) const -> . NUMBER
    (109) const -> . STRING
    (110) const -> . CHARACTER
    (111) const -> . TRUE
    (112) const -> . FALSE

    ID              shift and go to state 65
    THIS            shift and go to state 71
    NUMBER          shift and go to state 74
    STRING          shift and go to state 75
    CHARACTER       shift and go to state 76
    TRUE            shift and go to state 77
    FALSE           shift and go to state 78

    exp_math                       shift and go to state 168
    param                          shift and go to state 67
    const                          shift and go to state 72

state 149

    (104) array_size -> LSBRACKET exp_math RSBRACKET array_size_non_empty .

    LPAREN          reduce using rule 104 (array_size -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    DOT             reduce using rule 104 (array_size -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    LSBRACKET       reduce using rule 104 (array_size -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    PLUS            reduce using rule 104 (array_size -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    MINUS           reduce using rule 104 (array_size -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    TIMES           reduce using rule 104 (array_size -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    DIVIDE          reduce using rule 104 (array_size -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    MORETHAN        reduce using rule 104 (array_size -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    LESSTHAN        reduce using rule 104 (array_size -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    MOREOREQUALTHAN reduce using rule 104 (array_size -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    LESSOREQUALTHAN reduce using rule 104 (array_size -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    DOUBLEEQUALS    reduce using rule 104 (array_size -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    NOTEQUAL        reduce using rule 104 (array_size -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    ID              reduce using rule 104 (array_size -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    COMMA           reduce using rule 104 (array_size -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    SEMICOLON       reduce using rule 104 (array_size -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    RPAREN          reduce using rule 104 (array_size -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    RSBRACKET       reduce using rule 104 (array_size -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    ASSIGNMENT      reduce using rule 104 (array_size -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)


state 150

    (107) array_size_non_empty -> empty .

    LPAREN          reduce using rule 107 (array_size_non_empty -> empty .)
    DOT             reduce using rule 107 (array_size_non_empty -> empty .)
    LSBRACKET       reduce using rule 107 (array_size_non_empty -> empty .)
    PLUS            reduce using rule 107 (array_size_non_empty -> empty .)
    MINUS           reduce using rule 107 (array_size_non_empty -> empty .)
    TIMES           reduce using rule 107 (array_size_non_empty -> empty .)
    DIVIDE          reduce using rule 107 (array_size_non_empty -> empty .)
    MORETHAN        reduce using rule 107 (array_size_non_empty -> empty .)
    LESSTHAN        reduce using rule 107 (array_size_non_empty -> empty .)
    MOREOREQUALTHAN reduce using rule 107 (array_size_non_empty -> empty .)
    LESSOREQUALTHAN reduce using rule 107 (array_size_non_empty -> empty .)
    DOUBLEEQUALS    reduce using rule 107 (array_size_non_empty -> empty .)
    NOTEQUAL        reduce using rule 107 (array_size_non_empty -> empty .)
    ID              reduce using rule 107 (array_size_non_empty -> empty .)
    COMMA           reduce using rule 107 (array_size_non_empty -> empty .)
    SEMICOLON       reduce using rule 107 (array_size_non_empty -> empty .)
    RPAREN          reduce using rule 107 (array_size_non_empty -> empty .)
    RSBRACKET       reduce using rule 107 (array_size_non_empty -> empty .)
    ASSIGNMENT      reduce using rule 107 (array_size_non_empty -> empty .)


state 151

    (76) exp_logic -> NEW type name op_logic exp_logic_tail .

    ID              reduce using rule 76 (exp_logic -> NEW type name op_logic exp_logic_tail .)
    LPAREN          reduce using rule 76 (exp_logic -> NEW type name op_logic exp_logic_tail .)
    DOT             reduce using rule 76 (exp_logic -> NEW type name op_logic exp_logic_tail .)
    LSBRACKET       reduce using rule 76 (exp_logic -> NEW type name op_logic exp_logic_tail .)
    MORETHAN        reduce using rule 76 (exp_logic -> NEW type name op_logic exp_logic_tail .)
    LESSTHAN        reduce using rule 76 (exp_logic -> NEW type name op_logic exp_logic_tail .)
    MOREOREQUALTHAN reduce using rule 76 (exp_logic -> NEW type name op_logic exp_logic_tail .)
    LESSOREQUALTHAN reduce using rule 76 (exp_logic -> NEW type name op_logic exp_logic_tail .)
    DOUBLEEQUALS    reduce using rule 76 (exp_logic -> NEW type name op_logic exp_logic_tail .)
    NOTEQUAL        reduce using rule 76 (exp_logic -> NEW type name op_logic exp_logic_tail .)
    COMMA           reduce using rule 76 (exp_logic -> NEW type name op_logic exp_logic_tail .)
    SEMICOLON       reduce using rule 76 (exp_logic -> NEW type name op_logic exp_logic_tail .)
    RPAREN          reduce using rule 76 (exp_logic -> NEW type name op_logic exp_logic_tail .)


state 152

    (43) bloc_com -> LCURLYBRACE com_list . RCURLYBRACE

    RCURLYBRACE     shift and go to state 169


state 153

    (46) com_list -> command . com_list
    (46) com_list -> . command com_list
    (47) com_list -> . empty
    (48) command -> . atrib SEMICOLON
    (49) command -> . WHILE LPAREN exp_logic RPAREN bloc
    (50) command -> . DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON
    (51) command -> . IF LPAREN exp_logic RPAREN bloc else
    (52) command -> . FOR LPAREN for_exp RPAREN bloc
    (53) command -> . SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE
    (54) command -> . BREAK SEMICOLON
    (55) command -> . CONTINUE SEMICOLON
    (56) command -> . RETURN exp SEMICOLON
    (113) empty -> .
    (57) atrib -> . ID name ASSIGNMENT exp

    WHILE           shift and go to state 156
    DO              shift and go to state 157
    IF              shift and go to state 158
    FOR             shift and go to state 159
    SWITCH          shift and go to state 160
    BREAK           shift and go to state 162
    CONTINUE        shift and go to state 163
    RETURN          shift and go to state 164
    RCURLYBRACE     reduce using rule 113 (empty -> .)
    ID              shift and go to state 161

    command                        shift and go to state 153
    com_list                       shift and go to state 170
    empty                          shift and go to state 154
    atrib                          shift and go to state 155

state 154

    (47) com_list -> empty .

    RCURLYBRACE     reduce using rule 47 (com_list -> empty .)


state 155

    (48) command -> atrib . SEMICOLON

    SEMICOLON       shift and go to state 171


state 156

    (49) command -> WHILE . LPAREN exp_logic RPAREN bloc

    LPAREN          shift and go to state 172


state 157

    (50) command -> DO . bloc WHILE LPAREN exp_logic RPAREN SEMICOLON
    (44) bloc -> . bloc_com
    (45) bloc -> . command SEMICOLON
    (43) bloc_com -> . LCURLYBRACE com_list RCURLYBRACE
    (48) command -> . atrib SEMICOLON
    (49) command -> . WHILE LPAREN exp_logic RPAREN bloc
    (50) command -> . DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON
    (51) command -> . IF LPAREN exp_logic RPAREN bloc else
    (52) command -> . FOR LPAREN for_exp RPAREN bloc
    (53) command -> . SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE
    (54) command -> . BREAK SEMICOLON
    (55) command -> . CONTINUE SEMICOLON
    (56) command -> . RETURN exp SEMICOLON
    (57) atrib -> . ID name ASSIGNMENT exp

    LCURLYBRACE     shift and go to state 140
    WHILE           shift and go to state 156
    DO              shift and go to state 157
    IF              shift and go to state 158
    FOR             shift and go to state 159
    SWITCH          shift and go to state 160
    BREAK           shift and go to state 162
    CONTINUE        shift and go to state 163
    RETURN          shift and go to state 164
    ID              shift and go to state 161

    bloc                           shift and go to state 173
    bloc_com                       shift and go to state 174
    command                        shift and go to state 175
    atrib                          shift and go to state 155

state 158

    (51) command -> IF . LPAREN exp_logic RPAREN bloc else

    LPAREN          shift and go to state 176


state 159

    (52) command -> FOR . LPAREN for_exp RPAREN bloc

    LPAREN          shift and go to state 177


state 160

    (53) command -> SWITCH . LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE

    LPAREN          shift and go to state 178


state 161

    (57) atrib -> ID . name ASSIGNMENT exp
    (95) name -> . field
    (96) name -> . array_size name_non_empty
    (97) name -> . LPAREN params RPAREN name_non_empty
    (98) name -> . empty
    (102) field -> . DOT ID name_non_empty
    (103) field -> . empty
    (104) array_size -> . LSBRACKET exp_math RSBRACKET array_size_non_empty
    (105) array_size -> . empty
    (113) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LSBRACKET resolved as shift
    LPAREN          shift and go to state 95
    DOT             shift and go to state 97
    LSBRACKET       shift and go to state 98
    ASSIGNMENT      reduce using rule 113 (empty -> .)

  ! LPAREN          [ reduce using rule 113 (empty -> .) ]
  ! DOT             [ reduce using rule 113 (empty -> .) ]
  ! LSBRACKET       [ reduce using rule 113 (empty -> .) ]

    name                           shift and go to state 179
    field                          shift and go to state 93
    array_size                     shift and go to state 94
    empty                          shift and go to state 96

state 162

    (54) command -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 180


state 163

    (55) command -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 181


state 164

    (56) command -> RETURN . exp SEMICOLON
    (64) exp -> . exp_math
    (65) exp -> . exp_logic
    (66) exp -> . operator ID name
    (67) exp -> . NEW type name
    (80) exp_math -> . param op_math exp_math
    (81) exp_math -> . param
    (74) exp_logic -> . exp_math op_logic exp_logic_tail
    (75) exp_logic -> . operator ID name op_logic exp_logic_tail
    (76) exp_logic -> . NEW type name op_logic exp_logic_tail
    (77) exp_logic -> . exp_logic_tail
    (68) operator -> . DOUBLEPLUS
    (69) operator -> . DOUBLEMINUS
    (92) param -> . ID name
    (93) param -> . THIS field
    (94) param -> . const
    (78) exp_logic_tail -> . exp_math
    (79) exp_logic_tail -> . empty
    (108) const -> . NUMBER
    (109) const -> . STRING
    (110) const -> . CHARACTER
    (111) const -> . TRUE
    (112) const -> . FALSE
    (113) empty -> .

    NEW             shift and go to state 66
    DOUBLEPLUS      shift and go to state 69
    DOUBLEMINUS     shift and go to state 70
    ID              shift and go to state 65
    THIS            shift and go to state 71
    NUMBER          shift and go to state 74
    STRING          shift and go to state 75
    CHARACTER       shift and go to state 76
    TRUE            shift and go to state 77
    FALSE           shift and go to state 78
    SEMICOLON       reduce using rule 113 (empty -> .)

    exp                            shift and go to state 182
    exp_math                       shift and go to state 62
    exp_logic                      shift and go to state 63
    operator                       shift and go to state 64
    param                          shift and go to state 67
    exp_logic_tail                 shift and go to state 68
    const                          shift and go to state 72
    empty                          shift and go to state 73

state 165

    (41) arg_list -> COMMA argument .

    RPAREN          reduce using rule 41 (arg_list -> COMMA argument .)


state 166

    (101) name_non_empty -> LPAREN params RPAREN name_non_empty .

    PLUS            reduce using rule 101 (name_non_empty -> LPAREN params RPAREN name_non_empty .)
    MINUS           reduce using rule 101 (name_non_empty -> LPAREN params RPAREN name_non_empty .)
    TIMES           reduce using rule 101 (name_non_empty -> LPAREN params RPAREN name_non_empty .)
    DIVIDE          reduce using rule 101 (name_non_empty -> LPAREN params RPAREN name_non_empty .)
    MORETHAN        reduce using rule 101 (name_non_empty -> LPAREN params RPAREN name_non_empty .)
    LESSTHAN        reduce using rule 101 (name_non_empty -> LPAREN params RPAREN name_non_empty .)
    MOREOREQUALTHAN reduce using rule 101 (name_non_empty -> LPAREN params RPAREN name_non_empty .)
    LESSOREQUALTHAN reduce using rule 101 (name_non_empty -> LPAREN params RPAREN name_non_empty .)
    DOUBLEEQUALS    reduce using rule 101 (name_non_empty -> LPAREN params RPAREN name_non_empty .)
    NOTEQUAL        reduce using rule 101 (name_non_empty -> LPAREN params RPAREN name_non_empty .)
    ID              reduce using rule 101 (name_non_empty -> LPAREN params RPAREN name_non_empty .)
    LPAREN          reduce using rule 101 (name_non_empty -> LPAREN params RPAREN name_non_empty .)
    DOT             reduce using rule 101 (name_non_empty -> LPAREN params RPAREN name_non_empty .)
    LSBRACKET       reduce using rule 101 (name_non_empty -> LPAREN params RPAREN name_non_empty .)
    COMMA           reduce using rule 101 (name_non_empty -> LPAREN params RPAREN name_non_empty .)
    SEMICOLON       reduce using rule 101 (name_non_empty -> LPAREN params RPAREN name_non_empty .)
    RPAREN          reduce using rule 101 (name_non_empty -> LPAREN params RPAREN name_non_empty .)
    RSBRACKET       reduce using rule 101 (name_non_empty -> LPAREN params RPAREN name_non_empty .)
    ASSIGNMENT      reduce using rule 101 (name_non_empty -> LPAREN params RPAREN name_non_empty .)


state 167

    (72) param_list -> COMMA param param_list .

    RPAREN          reduce using rule 72 (param_list -> COMMA param param_list .)


state 168

    (106) array_size_non_empty -> LSBRACKET exp_math . RSBRACKET array_size_non_empty

    RSBRACKET       shift and go to state 183


state 169

    (43) bloc_com -> LCURLYBRACE com_list RCURLYBRACE .

    SEMICOLON       reduce using rule 43 (bloc_com -> LCURLYBRACE com_list RCURLYBRACE .)
    WHILE           reduce using rule 43 (bloc_com -> LCURLYBRACE com_list RCURLYBRACE .)
    DO              reduce using rule 43 (bloc_com -> LCURLYBRACE com_list RCURLYBRACE .)
    IF              reduce using rule 43 (bloc_com -> LCURLYBRACE com_list RCURLYBRACE .)
    FOR             reduce using rule 43 (bloc_com -> LCURLYBRACE com_list RCURLYBRACE .)
    SWITCH          reduce using rule 43 (bloc_com -> LCURLYBRACE com_list RCURLYBRACE .)
    BREAK           reduce using rule 43 (bloc_com -> LCURLYBRACE com_list RCURLYBRACE .)
    CONTINUE        reduce using rule 43 (bloc_com -> LCURLYBRACE com_list RCURLYBRACE .)
    RETURN          reduce using rule 43 (bloc_com -> LCURLYBRACE com_list RCURLYBRACE .)
    ID              reduce using rule 43 (bloc_com -> LCURLYBRACE com_list RCURLYBRACE .)
    RCURLYBRACE     reduce using rule 43 (bloc_com -> LCURLYBRACE com_list RCURLYBRACE .)
    ELSE            reduce using rule 43 (bloc_com -> LCURLYBRACE com_list RCURLYBRACE .)
    CASE            reduce using rule 43 (bloc_com -> LCURLYBRACE com_list RCURLYBRACE .)
    DEFAULT         reduce using rule 43 (bloc_com -> LCURLYBRACE com_list RCURLYBRACE .)


state 170

    (46) com_list -> command com_list .

    RCURLYBRACE     reduce using rule 46 (com_list -> command com_list .)


state 171

    (48) command -> atrib SEMICOLON .

    WHILE           reduce using rule 48 (command -> atrib SEMICOLON .)
    DO              reduce using rule 48 (command -> atrib SEMICOLON .)
    IF              reduce using rule 48 (command -> atrib SEMICOLON .)
    FOR             reduce using rule 48 (command -> atrib SEMICOLON .)
    SWITCH          reduce using rule 48 (command -> atrib SEMICOLON .)
    BREAK           reduce using rule 48 (command -> atrib SEMICOLON .)
    CONTINUE        reduce using rule 48 (command -> atrib SEMICOLON .)
    RETURN          reduce using rule 48 (command -> atrib SEMICOLON .)
    ID              reduce using rule 48 (command -> atrib SEMICOLON .)
    RCURLYBRACE     reduce using rule 48 (command -> atrib SEMICOLON .)
    SEMICOLON       reduce using rule 48 (command -> atrib SEMICOLON .)


state 172

    (49) command -> WHILE LPAREN . exp_logic RPAREN bloc
    (74) exp_logic -> . exp_math op_logic exp_logic_tail
    (75) exp_logic -> . operator ID name op_logic exp_logic_tail
    (76) exp_logic -> . NEW type name op_logic exp_logic_tail
    (77) exp_logic -> . exp_logic_tail
    (80) exp_math -> . param op_math exp_math
    (81) exp_math -> . param
    (68) operator -> . DOUBLEPLUS
    (69) operator -> . DOUBLEMINUS
    (78) exp_logic_tail -> . exp_math
    (79) exp_logic_tail -> . empty
    (92) param -> . ID name
    (93) param -> . THIS field
    (94) param -> . const
    (113) empty -> .
    (108) const -> . NUMBER
    (109) const -> . STRING
    (110) const -> . CHARACTER
    (111) const -> . TRUE
    (112) const -> . FALSE

    NEW             shift and go to state 187
    DOUBLEPLUS      shift and go to state 69
    DOUBLEMINUS     shift and go to state 70
    ID              shift and go to state 65
    THIS            shift and go to state 71
    RPAREN          reduce using rule 113 (empty -> .)
    NUMBER          shift and go to state 74
    STRING          shift and go to state 75
    CHARACTER       shift and go to state 76
    TRUE            shift and go to state 77
    FALSE           shift and go to state 78

    exp_logic                      shift and go to state 184
    exp_math                       shift and go to state 185
    exp_logic_tail                 shift and go to state 68
    operator                       shift and go to state 186
    param                          shift and go to state 67
    empty                          shift and go to state 73
    const                          shift and go to state 72

state 173

    (50) command -> DO bloc . WHILE LPAREN exp_logic RPAREN SEMICOLON

    WHILE           shift and go to state 188


state 174

    (44) bloc -> bloc_com .

    WHILE           reduce using rule 44 (bloc -> bloc_com .)
    DO              reduce using rule 44 (bloc -> bloc_com .)
    IF              reduce using rule 44 (bloc -> bloc_com .)
    FOR             reduce using rule 44 (bloc -> bloc_com .)
    SWITCH          reduce using rule 44 (bloc -> bloc_com .)
    BREAK           reduce using rule 44 (bloc -> bloc_com .)
    CONTINUE        reduce using rule 44 (bloc -> bloc_com .)
    RETURN          reduce using rule 44 (bloc -> bloc_com .)
    ID              reduce using rule 44 (bloc -> bloc_com .)
    RCURLYBRACE     reduce using rule 44 (bloc -> bloc_com .)
    SEMICOLON       reduce using rule 44 (bloc -> bloc_com .)
    ELSE            reduce using rule 44 (bloc -> bloc_com .)
    CASE            reduce using rule 44 (bloc -> bloc_com .)
    DEFAULT         reduce using rule 44 (bloc -> bloc_com .)


state 175

    (45) bloc -> command . SEMICOLON

    SEMICOLON       shift and go to state 189


state 176

    (51) command -> IF LPAREN . exp_logic RPAREN bloc else
    (74) exp_logic -> . exp_math op_logic exp_logic_tail
    (75) exp_logic -> . operator ID name op_logic exp_logic_tail
    (76) exp_logic -> . NEW type name op_logic exp_logic_tail
    (77) exp_logic -> . exp_logic_tail
    (80) exp_math -> . param op_math exp_math
    (81) exp_math -> . param
    (68) operator -> . DOUBLEPLUS
    (69) operator -> . DOUBLEMINUS
    (78) exp_logic_tail -> . exp_math
    (79) exp_logic_tail -> . empty
    (92) param -> . ID name
    (93) param -> . THIS field
    (94) param -> . const
    (113) empty -> .
    (108) const -> . NUMBER
    (109) const -> . STRING
    (110) const -> . CHARACTER
    (111) const -> . TRUE
    (112) const -> . FALSE

    NEW             shift and go to state 187
    DOUBLEPLUS      shift and go to state 69
    DOUBLEMINUS     shift and go to state 70
    ID              shift and go to state 65
    THIS            shift and go to state 71
    RPAREN          reduce using rule 113 (empty -> .)
    NUMBER          shift and go to state 74
    STRING          shift and go to state 75
    CHARACTER       shift and go to state 76
    TRUE            shift and go to state 77
    FALSE           shift and go to state 78

    exp_logic                      shift and go to state 190
    exp_math                       shift and go to state 185
    exp_logic_tail                 shift and go to state 68
    operator                       shift and go to state 186
    param                          shift and go to state 67
    empty                          shift and go to state 73
    const                          shift and go to state 72

state 177

    (52) command -> FOR LPAREN . for_exp RPAREN bloc
    (60) for_exp -> . atrib_decl SEMICOLON exp_logic SEMICOLON atrib
    (61) for_exp -> . type ID COLON ID name
    (23) atrib_decl -> . type var var_list SEMICOLON
    (25) type -> . INT
    (26) type -> . FLOAT
    (27) type -> . DOUBLE
    (28) type -> . CHAR
    (29) type -> . VOID
    (30) type -> . ID value

    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    DOUBLE          shift and go to state 41
    CHAR            shift and go to state 42
    VOID            shift and go to state 43
    ID              shift and go to state 44

    for_exp                        shift and go to state 191
    atrib_decl                     shift and go to state 192
    type                           shift and go to state 193

state 178

    (53) command -> SWITCH LPAREN . ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE

    ID              shift and go to state 194


state 179

    (57) atrib -> ID name . ASSIGNMENT exp

    ASSIGNMENT      shift and go to state 195


state 180

    (54) command -> BREAK SEMICOLON .

    WHILE           reduce using rule 54 (command -> BREAK SEMICOLON .)
    DO              reduce using rule 54 (command -> BREAK SEMICOLON .)
    IF              reduce using rule 54 (command -> BREAK SEMICOLON .)
    FOR             reduce using rule 54 (command -> BREAK SEMICOLON .)
    SWITCH          reduce using rule 54 (command -> BREAK SEMICOLON .)
    BREAK           reduce using rule 54 (command -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 54 (command -> BREAK SEMICOLON .)
    RETURN          reduce using rule 54 (command -> BREAK SEMICOLON .)
    ID              reduce using rule 54 (command -> BREAK SEMICOLON .)
    RCURLYBRACE     reduce using rule 54 (command -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 54 (command -> BREAK SEMICOLON .)


state 181

    (55) command -> CONTINUE SEMICOLON .

    WHILE           reduce using rule 55 (command -> CONTINUE SEMICOLON .)
    DO              reduce using rule 55 (command -> CONTINUE SEMICOLON .)
    IF              reduce using rule 55 (command -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 55 (command -> CONTINUE SEMICOLON .)
    SWITCH          reduce using rule 55 (command -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 55 (command -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 55 (command -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 55 (command -> CONTINUE SEMICOLON .)
    ID              reduce using rule 55 (command -> CONTINUE SEMICOLON .)
    RCURLYBRACE     reduce using rule 55 (command -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 55 (command -> CONTINUE SEMICOLON .)


state 182

    (56) command -> RETURN exp . SEMICOLON

    SEMICOLON       shift and go to state 196


state 183

    (106) array_size_non_empty -> LSBRACKET exp_math RSBRACKET . array_size_non_empty
    (106) array_size_non_empty -> . LSBRACKET exp_math RSBRACKET array_size_non_empty
    (107) array_size_non_empty -> . empty
    (113) empty -> .

  ! shift/reduce conflict for LSBRACKET resolved as shift
    LSBRACKET       shift and go to state 148
    LPAREN          reduce using rule 113 (empty -> .)
    DOT             reduce using rule 113 (empty -> .)
    PLUS            reduce using rule 113 (empty -> .)
    MINUS           reduce using rule 113 (empty -> .)
    TIMES           reduce using rule 113 (empty -> .)
    DIVIDE          reduce using rule 113 (empty -> .)
    MORETHAN        reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    MOREOREQUALTHAN reduce using rule 113 (empty -> .)
    LESSOREQUALTHAN reduce using rule 113 (empty -> .)
    DOUBLEEQUALS    reduce using rule 113 (empty -> .)
    NOTEQUAL        reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)
    RSBRACKET       reduce using rule 113 (empty -> .)
    ASSIGNMENT      reduce using rule 113 (empty -> .)

  ! LSBRACKET       [ reduce using rule 113 (empty -> .) ]

    array_size_non_empty           shift and go to state 197
    empty                          shift and go to state 150

state 184

    (49) command -> WHILE LPAREN exp_logic . RPAREN bloc

    RPAREN          shift and go to state 198


state 185

    (74) exp_logic -> exp_math . op_logic exp_logic_tail
    (78) exp_logic_tail -> exp_math .
    (82) op_logic -> . MORETHAN
    (83) op_logic -> . LESSTHAN
    (84) op_logic -> . MOREOREQUALTHAN
    (85) op_logic -> . LESSOREQUALTHAN
    (86) op_logic -> . DOUBLEEQUALS
    (87) op_logic -> . NOTEQUAL

    RPAREN          reduce using rule 78 (exp_logic_tail -> exp_math .)
    SEMICOLON       reduce using rule 78 (exp_logic_tail -> exp_math .)
    MORETHAN        shift and go to state 85
    LESSTHAN        shift and go to state 86
    MOREOREQUALTHAN shift and go to state 87
    LESSOREQUALTHAN shift and go to state 88
    DOUBLEEQUALS    shift and go to state 89
    NOTEQUAL        shift and go to state 90

    op_logic                       shift and go to state 84

state 186

    (75) exp_logic -> operator . ID name op_logic exp_logic_tail

    ID              shift and go to state 199


state 187

    (76) exp_logic -> NEW . type name op_logic exp_logic_tail
    (25) type -> . INT
    (26) type -> . FLOAT
    (27) type -> . DOUBLE
    (28) type -> . CHAR
    (29) type -> . VOID
    (30) type -> . ID value

    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    DOUBLE          shift and go to state 41
    CHAR            shift and go to state 42
    VOID            shift and go to state 43
    ID              shift and go to state 44

    type                           shift and go to state 200

state 188

    (50) command -> DO bloc WHILE . LPAREN exp_logic RPAREN SEMICOLON

    LPAREN          shift and go to state 201


state 189

    (45) bloc -> command SEMICOLON .

    WHILE           reduce using rule 45 (bloc -> command SEMICOLON .)
    DO              reduce using rule 45 (bloc -> command SEMICOLON .)
    IF              reduce using rule 45 (bloc -> command SEMICOLON .)
    FOR             reduce using rule 45 (bloc -> command SEMICOLON .)
    SWITCH          reduce using rule 45 (bloc -> command SEMICOLON .)
    BREAK           reduce using rule 45 (bloc -> command SEMICOLON .)
    CONTINUE        reduce using rule 45 (bloc -> command SEMICOLON .)
    RETURN          reduce using rule 45 (bloc -> command SEMICOLON .)
    ID              reduce using rule 45 (bloc -> command SEMICOLON .)
    RCURLYBRACE     reduce using rule 45 (bloc -> command SEMICOLON .)
    SEMICOLON       reduce using rule 45 (bloc -> command SEMICOLON .)
    ELSE            reduce using rule 45 (bloc -> command SEMICOLON .)
    CASE            reduce using rule 45 (bloc -> command SEMICOLON .)
    DEFAULT         reduce using rule 45 (bloc -> command SEMICOLON .)


state 190

    (51) command -> IF LPAREN exp_logic . RPAREN bloc else

    RPAREN          shift and go to state 202


state 191

    (52) command -> FOR LPAREN for_exp . RPAREN bloc

    RPAREN          shift and go to state 203


state 192

    (60) for_exp -> atrib_decl . SEMICOLON exp_logic SEMICOLON atrib

    SEMICOLON       shift and go to state 204


state 193

    (61) for_exp -> type . ID COLON ID name
    (23) atrib_decl -> type . var var_list SEMICOLON
    (31) var -> . ID array value

    ID              shift and go to state 205

    var                            shift and go to state 46

state 194

    (53) command -> SWITCH LPAREN ID . name RPAREN LCURLYBRACE switch_case RCURLYBRACE
    (95) name -> . field
    (96) name -> . array_size name_non_empty
    (97) name -> . LPAREN params RPAREN name_non_empty
    (98) name -> . empty
    (102) field -> . DOT ID name_non_empty
    (103) field -> . empty
    (104) array_size -> . LSBRACKET exp_math RSBRACKET array_size_non_empty
    (105) array_size -> . empty
    (113) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LSBRACKET resolved as shift
    LPAREN          shift and go to state 95
    DOT             shift and go to state 97
    LSBRACKET       shift and go to state 98
    RPAREN          reduce using rule 113 (empty -> .)

  ! LPAREN          [ reduce using rule 113 (empty -> .) ]
  ! DOT             [ reduce using rule 113 (empty -> .) ]
  ! LSBRACKET       [ reduce using rule 113 (empty -> .) ]

    name                           shift and go to state 206
    field                          shift and go to state 93
    array_size                     shift and go to state 94
    empty                          shift and go to state 96

state 195

    (57) atrib -> ID name ASSIGNMENT . exp
    (64) exp -> . exp_math
    (65) exp -> . exp_logic
    (66) exp -> . operator ID name
    (67) exp -> . NEW type name
    (80) exp_math -> . param op_math exp_math
    (81) exp_math -> . param
    (74) exp_logic -> . exp_math op_logic exp_logic_tail
    (75) exp_logic -> . operator ID name op_logic exp_logic_tail
    (76) exp_logic -> . NEW type name op_logic exp_logic_tail
    (77) exp_logic -> . exp_logic_tail
    (68) operator -> . DOUBLEPLUS
    (69) operator -> . DOUBLEMINUS
    (92) param -> . ID name
    (93) param -> . THIS field
    (94) param -> . const
    (78) exp_logic_tail -> . exp_math
    (79) exp_logic_tail -> . empty
    (108) const -> . NUMBER
    (109) const -> . STRING
    (110) const -> . CHARACTER
    (111) const -> . TRUE
    (112) const -> . FALSE
    (113) empty -> .

    NEW             shift and go to state 66
    DOUBLEPLUS      shift and go to state 69
    DOUBLEMINUS     shift and go to state 70
    ID              shift and go to state 65
    THIS            shift and go to state 71
    NUMBER          shift and go to state 74
    STRING          shift and go to state 75
    CHARACTER       shift and go to state 76
    TRUE            shift and go to state 77
    FALSE           shift and go to state 78
    SEMICOLON       reduce using rule 113 (empty -> .)
    RPAREN          reduce using rule 113 (empty -> .)

    exp                            shift and go to state 207
    exp_math                       shift and go to state 62
    exp_logic                      shift and go to state 63
    operator                       shift and go to state 64
    param                          shift and go to state 67
    exp_logic_tail                 shift and go to state 68
    const                          shift and go to state 72
    empty                          shift and go to state 73

state 196

    (56) command -> RETURN exp SEMICOLON .

    WHILE           reduce using rule 56 (command -> RETURN exp SEMICOLON .)
    DO              reduce using rule 56 (command -> RETURN exp SEMICOLON .)
    IF              reduce using rule 56 (command -> RETURN exp SEMICOLON .)
    FOR             reduce using rule 56 (command -> RETURN exp SEMICOLON .)
    SWITCH          reduce using rule 56 (command -> RETURN exp SEMICOLON .)
    BREAK           reduce using rule 56 (command -> RETURN exp SEMICOLON .)
    CONTINUE        reduce using rule 56 (command -> RETURN exp SEMICOLON .)
    RETURN          reduce using rule 56 (command -> RETURN exp SEMICOLON .)
    ID              reduce using rule 56 (command -> RETURN exp SEMICOLON .)
    RCURLYBRACE     reduce using rule 56 (command -> RETURN exp SEMICOLON .)
    SEMICOLON       reduce using rule 56 (command -> RETURN exp SEMICOLON .)


state 197

    (106) array_size_non_empty -> LSBRACKET exp_math RSBRACKET array_size_non_empty .

    LPAREN          reduce using rule 106 (array_size_non_empty -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    DOT             reduce using rule 106 (array_size_non_empty -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    LSBRACKET       reduce using rule 106 (array_size_non_empty -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    PLUS            reduce using rule 106 (array_size_non_empty -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    MINUS           reduce using rule 106 (array_size_non_empty -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    TIMES           reduce using rule 106 (array_size_non_empty -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    DIVIDE          reduce using rule 106 (array_size_non_empty -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    MORETHAN        reduce using rule 106 (array_size_non_empty -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    LESSTHAN        reduce using rule 106 (array_size_non_empty -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    MOREOREQUALTHAN reduce using rule 106 (array_size_non_empty -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    LESSOREQUALTHAN reduce using rule 106 (array_size_non_empty -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    DOUBLEEQUALS    reduce using rule 106 (array_size_non_empty -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    NOTEQUAL        reduce using rule 106 (array_size_non_empty -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    ID              reduce using rule 106 (array_size_non_empty -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    COMMA           reduce using rule 106 (array_size_non_empty -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    SEMICOLON       reduce using rule 106 (array_size_non_empty -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    RPAREN          reduce using rule 106 (array_size_non_empty -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    RSBRACKET       reduce using rule 106 (array_size_non_empty -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)
    ASSIGNMENT      reduce using rule 106 (array_size_non_empty -> LSBRACKET exp_math RSBRACKET array_size_non_empty .)


state 198

    (49) command -> WHILE LPAREN exp_logic RPAREN . bloc
    (44) bloc -> . bloc_com
    (45) bloc -> . command SEMICOLON
    (43) bloc_com -> . LCURLYBRACE com_list RCURLYBRACE
    (48) command -> . atrib SEMICOLON
    (49) command -> . WHILE LPAREN exp_logic RPAREN bloc
    (50) command -> . DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON
    (51) command -> . IF LPAREN exp_logic RPAREN bloc else
    (52) command -> . FOR LPAREN for_exp RPAREN bloc
    (53) command -> . SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE
    (54) command -> . BREAK SEMICOLON
    (55) command -> . CONTINUE SEMICOLON
    (56) command -> . RETURN exp SEMICOLON
    (57) atrib -> . ID name ASSIGNMENT exp

    LCURLYBRACE     shift and go to state 140
    WHILE           shift and go to state 156
    DO              shift and go to state 157
    IF              shift and go to state 158
    FOR             shift and go to state 159
    SWITCH          shift and go to state 160
    BREAK           shift and go to state 162
    CONTINUE        shift and go to state 163
    RETURN          shift and go to state 164
    ID              shift and go to state 161

    bloc                           shift and go to state 208
    bloc_com                       shift and go to state 174
    command                        shift and go to state 175
    atrib                          shift and go to state 155

state 199

    (75) exp_logic -> operator ID . name op_logic exp_logic_tail
    (95) name -> . field
    (96) name -> . array_size name_non_empty
    (97) name -> . LPAREN params RPAREN name_non_empty
    (98) name -> . empty
    (102) field -> . DOT ID name_non_empty
    (103) field -> . empty
    (104) array_size -> . LSBRACKET exp_math RSBRACKET array_size_non_empty
    (105) array_size -> . empty
    (113) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LSBRACKET resolved as shift
    LPAREN          shift and go to state 95
    DOT             shift and go to state 97
    LSBRACKET       shift and go to state 98
    MORETHAN        reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    MOREOREQUALTHAN reduce using rule 113 (empty -> .)
    LESSOREQUALTHAN reduce using rule 113 (empty -> .)
    DOUBLEEQUALS    reduce using rule 113 (empty -> .)
    NOTEQUAL        reduce using rule 113 (empty -> .)

  ! LPAREN          [ reduce using rule 113 (empty -> .) ]
  ! DOT             [ reduce using rule 113 (empty -> .) ]
  ! LSBRACKET       [ reduce using rule 113 (empty -> .) ]

    name                           shift and go to state 209
    field                          shift and go to state 93
    array_size                     shift and go to state 94
    empty                          shift and go to state 96

state 200

    (76) exp_logic -> NEW type . name op_logic exp_logic_tail
    (95) name -> . field
    (96) name -> . array_size name_non_empty
    (97) name -> . LPAREN params RPAREN name_non_empty
    (98) name -> . empty
    (102) field -> . DOT ID name_non_empty
    (103) field -> . empty
    (104) array_size -> . LSBRACKET exp_math RSBRACKET array_size_non_empty
    (105) array_size -> . empty
    (113) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LSBRACKET resolved as shift
    LPAREN          shift and go to state 95
    DOT             shift and go to state 97
    LSBRACKET       shift and go to state 98
    MORETHAN        reduce using rule 113 (empty -> .)
    LESSTHAN        reduce using rule 113 (empty -> .)
    MOREOREQUALTHAN reduce using rule 113 (empty -> .)
    LESSOREQUALTHAN reduce using rule 113 (empty -> .)
    DOUBLEEQUALS    reduce using rule 113 (empty -> .)
    NOTEQUAL        reduce using rule 113 (empty -> .)

  ! LPAREN          [ reduce using rule 113 (empty -> .) ]
  ! DOT             [ reduce using rule 113 (empty -> .) ]
  ! LSBRACKET       [ reduce using rule 113 (empty -> .) ]

    name                           shift and go to state 210
    field                          shift and go to state 93
    array_size                     shift and go to state 94
    empty                          shift and go to state 96

state 201

    (50) command -> DO bloc WHILE LPAREN . exp_logic RPAREN SEMICOLON
    (74) exp_logic -> . exp_math op_logic exp_logic_tail
    (75) exp_logic -> . operator ID name op_logic exp_logic_tail
    (76) exp_logic -> . NEW type name op_logic exp_logic_tail
    (77) exp_logic -> . exp_logic_tail
    (80) exp_math -> . param op_math exp_math
    (81) exp_math -> . param
    (68) operator -> . DOUBLEPLUS
    (69) operator -> . DOUBLEMINUS
    (78) exp_logic_tail -> . exp_math
    (79) exp_logic_tail -> . empty
    (92) param -> . ID name
    (93) param -> . THIS field
    (94) param -> . const
    (113) empty -> .
    (108) const -> . NUMBER
    (109) const -> . STRING
    (110) const -> . CHARACTER
    (111) const -> . TRUE
    (112) const -> . FALSE

    NEW             shift and go to state 187
    DOUBLEPLUS      shift and go to state 69
    DOUBLEMINUS     shift and go to state 70
    ID              shift and go to state 65
    THIS            shift and go to state 71
    RPAREN          reduce using rule 113 (empty -> .)
    NUMBER          shift and go to state 74
    STRING          shift and go to state 75
    CHARACTER       shift and go to state 76
    TRUE            shift and go to state 77
    FALSE           shift and go to state 78

    exp_logic                      shift and go to state 211
    exp_math                       shift and go to state 185
    exp_logic_tail                 shift and go to state 68
    operator                       shift and go to state 186
    param                          shift and go to state 67
    empty                          shift and go to state 73
    const                          shift and go to state 72

state 202

    (51) command -> IF LPAREN exp_logic RPAREN . bloc else
    (44) bloc -> . bloc_com
    (45) bloc -> . command SEMICOLON
    (43) bloc_com -> . LCURLYBRACE com_list RCURLYBRACE
    (48) command -> . atrib SEMICOLON
    (49) command -> . WHILE LPAREN exp_logic RPAREN bloc
    (50) command -> . DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON
    (51) command -> . IF LPAREN exp_logic RPAREN bloc else
    (52) command -> . FOR LPAREN for_exp RPAREN bloc
    (53) command -> . SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE
    (54) command -> . BREAK SEMICOLON
    (55) command -> . CONTINUE SEMICOLON
    (56) command -> . RETURN exp SEMICOLON
    (57) atrib -> . ID name ASSIGNMENT exp

    LCURLYBRACE     shift and go to state 140
    WHILE           shift and go to state 156
    DO              shift and go to state 157
    IF              shift and go to state 158
    FOR             shift and go to state 159
    SWITCH          shift and go to state 160
    BREAK           shift and go to state 162
    CONTINUE        shift and go to state 163
    RETURN          shift and go to state 164
    ID              shift and go to state 161

    bloc                           shift and go to state 212
    bloc_com                       shift and go to state 174
    command                        shift and go to state 175
    atrib                          shift and go to state 155

state 203

    (52) command -> FOR LPAREN for_exp RPAREN . bloc
    (44) bloc -> . bloc_com
    (45) bloc -> . command SEMICOLON
    (43) bloc_com -> . LCURLYBRACE com_list RCURLYBRACE
    (48) command -> . atrib SEMICOLON
    (49) command -> . WHILE LPAREN exp_logic RPAREN bloc
    (50) command -> . DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON
    (51) command -> . IF LPAREN exp_logic RPAREN bloc else
    (52) command -> . FOR LPAREN for_exp RPAREN bloc
    (53) command -> . SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE
    (54) command -> . BREAK SEMICOLON
    (55) command -> . CONTINUE SEMICOLON
    (56) command -> . RETURN exp SEMICOLON
    (57) atrib -> . ID name ASSIGNMENT exp

    LCURLYBRACE     shift and go to state 140
    WHILE           shift and go to state 156
    DO              shift and go to state 157
    IF              shift and go to state 158
    FOR             shift and go to state 159
    SWITCH          shift and go to state 160
    BREAK           shift and go to state 162
    CONTINUE        shift and go to state 163
    RETURN          shift and go to state 164
    ID              shift and go to state 161

    bloc                           shift and go to state 213
    bloc_com                       shift and go to state 174
    command                        shift and go to state 175
    atrib                          shift and go to state 155

state 204

    (60) for_exp -> atrib_decl SEMICOLON . exp_logic SEMICOLON atrib
    (74) exp_logic -> . exp_math op_logic exp_logic_tail
    (75) exp_logic -> . operator ID name op_logic exp_logic_tail
    (76) exp_logic -> . NEW type name op_logic exp_logic_tail
    (77) exp_logic -> . exp_logic_tail
    (80) exp_math -> . param op_math exp_math
    (81) exp_math -> . param
    (68) operator -> . DOUBLEPLUS
    (69) operator -> . DOUBLEMINUS
    (78) exp_logic_tail -> . exp_math
    (79) exp_logic_tail -> . empty
    (92) param -> . ID name
    (93) param -> . THIS field
    (94) param -> . const
    (113) empty -> .
    (108) const -> . NUMBER
    (109) const -> . STRING
    (110) const -> . CHARACTER
    (111) const -> . TRUE
    (112) const -> . FALSE

    NEW             shift and go to state 187
    DOUBLEPLUS      shift and go to state 69
    DOUBLEMINUS     shift and go to state 70
    ID              shift and go to state 65
    THIS            shift and go to state 71
    SEMICOLON       reduce using rule 113 (empty -> .)
    NUMBER          shift and go to state 74
    STRING          shift and go to state 75
    CHARACTER       shift and go to state 76
    TRUE            shift and go to state 77
    FALSE           shift and go to state 78

    exp_logic                      shift and go to state 214
    exp_math                       shift and go to state 185
    exp_logic_tail                 shift and go to state 68
    operator                       shift and go to state 186
    param                          shift and go to state 67
    empty                          shift and go to state 73
    const                          shift and go to state 72

state 205

    (61) for_exp -> type ID . COLON ID name
    (31) var -> ID . array value
    (36) array -> . LSBRACKET RSBRACKET array
    (37) array -> . empty
    (113) empty -> .

    COLON           shift and go to state 215
    LSBRACKET       shift and go to state 57
    ASSIGNMENT      reduce using rule 113 (empty -> .)
    COMMA           reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)

    array                          shift and go to state 56
    empty                          shift and go to state 58

state 206

    (53) command -> SWITCH LPAREN ID name . RPAREN LCURLYBRACE switch_case RCURLYBRACE

    RPAREN          shift and go to state 216


state 207

    (57) atrib -> ID name ASSIGNMENT exp .

    SEMICOLON       reduce using rule 57 (atrib -> ID name ASSIGNMENT exp .)
    RPAREN          reduce using rule 57 (atrib -> ID name ASSIGNMENT exp .)


state 208

    (49) command -> WHILE LPAREN exp_logic RPAREN bloc .

    WHILE           reduce using rule 49 (command -> WHILE LPAREN exp_logic RPAREN bloc .)
    DO              reduce using rule 49 (command -> WHILE LPAREN exp_logic RPAREN bloc .)
    IF              reduce using rule 49 (command -> WHILE LPAREN exp_logic RPAREN bloc .)
    FOR             reduce using rule 49 (command -> WHILE LPAREN exp_logic RPAREN bloc .)
    SWITCH          reduce using rule 49 (command -> WHILE LPAREN exp_logic RPAREN bloc .)
    BREAK           reduce using rule 49 (command -> WHILE LPAREN exp_logic RPAREN bloc .)
    CONTINUE        reduce using rule 49 (command -> WHILE LPAREN exp_logic RPAREN bloc .)
    RETURN          reduce using rule 49 (command -> WHILE LPAREN exp_logic RPAREN bloc .)
    ID              reduce using rule 49 (command -> WHILE LPAREN exp_logic RPAREN bloc .)
    RCURLYBRACE     reduce using rule 49 (command -> WHILE LPAREN exp_logic RPAREN bloc .)
    SEMICOLON       reduce using rule 49 (command -> WHILE LPAREN exp_logic RPAREN bloc .)


state 209

    (75) exp_logic -> operator ID name . op_logic exp_logic_tail
    (82) op_logic -> . MORETHAN
    (83) op_logic -> . LESSTHAN
    (84) op_logic -> . MOREOREQUALTHAN
    (85) op_logic -> . LESSOREQUALTHAN
    (86) op_logic -> . DOUBLEEQUALS
    (87) op_logic -> . NOTEQUAL

    MORETHAN        shift and go to state 85
    LESSTHAN        shift and go to state 86
    MOREOREQUALTHAN shift and go to state 87
    LESSOREQUALTHAN shift and go to state 88
    DOUBLEEQUALS    shift and go to state 89
    NOTEQUAL        shift and go to state 90

    op_logic                       shift and go to state 129

state 210

    (76) exp_logic -> NEW type name . op_logic exp_logic_tail
    (82) op_logic -> . MORETHAN
    (83) op_logic -> . LESSTHAN
    (84) op_logic -> . MOREOREQUALTHAN
    (85) op_logic -> . LESSOREQUALTHAN
    (86) op_logic -> . DOUBLEEQUALS
    (87) op_logic -> . NOTEQUAL

    MORETHAN        shift and go to state 85
    LESSTHAN        shift and go to state 86
    MOREOREQUALTHAN shift and go to state 87
    LESSOREQUALTHAN shift and go to state 88
    DOUBLEEQUALS    shift and go to state 89
    NOTEQUAL        shift and go to state 90

    op_logic                       shift and go to state 138

state 211

    (50) command -> DO bloc WHILE LPAREN exp_logic . RPAREN SEMICOLON

    RPAREN          shift and go to state 217


state 212

    (51) command -> IF LPAREN exp_logic RPAREN bloc . else
    (58) else -> . ELSE bloc
    (59) else -> . empty
    (113) empty -> .

    ELSE            shift and go to state 219
    WHILE           reduce using rule 113 (empty -> .)
    DO              reduce using rule 113 (empty -> .)
    IF              reduce using rule 113 (empty -> .)
    FOR             reduce using rule 113 (empty -> .)
    SWITCH          reduce using rule 113 (empty -> .)
    BREAK           reduce using rule 113 (empty -> .)
    CONTINUE        reduce using rule 113 (empty -> .)
    RETURN          reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    RCURLYBRACE     reduce using rule 113 (empty -> .)
    SEMICOLON       reduce using rule 113 (empty -> .)

    else                           shift and go to state 218
    empty                          shift and go to state 220

state 213

    (52) command -> FOR LPAREN for_exp RPAREN bloc .

    WHILE           reduce using rule 52 (command -> FOR LPAREN for_exp RPAREN bloc .)
    DO              reduce using rule 52 (command -> FOR LPAREN for_exp RPAREN bloc .)
    IF              reduce using rule 52 (command -> FOR LPAREN for_exp RPAREN bloc .)
    FOR             reduce using rule 52 (command -> FOR LPAREN for_exp RPAREN bloc .)
    SWITCH          reduce using rule 52 (command -> FOR LPAREN for_exp RPAREN bloc .)
    BREAK           reduce using rule 52 (command -> FOR LPAREN for_exp RPAREN bloc .)
    CONTINUE        reduce using rule 52 (command -> FOR LPAREN for_exp RPAREN bloc .)
    RETURN          reduce using rule 52 (command -> FOR LPAREN for_exp RPAREN bloc .)
    ID              reduce using rule 52 (command -> FOR LPAREN for_exp RPAREN bloc .)
    RCURLYBRACE     reduce using rule 52 (command -> FOR LPAREN for_exp RPAREN bloc .)
    SEMICOLON       reduce using rule 52 (command -> FOR LPAREN for_exp RPAREN bloc .)


state 214

    (60) for_exp -> atrib_decl SEMICOLON exp_logic . SEMICOLON atrib

    SEMICOLON       shift and go to state 221


state 215

    (61) for_exp -> type ID COLON . ID name

    ID              shift and go to state 222


state 216

    (53) command -> SWITCH LPAREN ID name RPAREN . LCURLYBRACE switch_case RCURLYBRACE

    LCURLYBRACE     shift and go to state 223


state 217

    (50) command -> DO bloc WHILE LPAREN exp_logic RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 224


state 218

    (51) command -> IF LPAREN exp_logic RPAREN bloc else .

    WHILE           reduce using rule 51 (command -> IF LPAREN exp_logic RPAREN bloc else .)
    DO              reduce using rule 51 (command -> IF LPAREN exp_logic RPAREN bloc else .)
    IF              reduce using rule 51 (command -> IF LPAREN exp_logic RPAREN bloc else .)
    FOR             reduce using rule 51 (command -> IF LPAREN exp_logic RPAREN bloc else .)
    SWITCH          reduce using rule 51 (command -> IF LPAREN exp_logic RPAREN bloc else .)
    BREAK           reduce using rule 51 (command -> IF LPAREN exp_logic RPAREN bloc else .)
    CONTINUE        reduce using rule 51 (command -> IF LPAREN exp_logic RPAREN bloc else .)
    RETURN          reduce using rule 51 (command -> IF LPAREN exp_logic RPAREN bloc else .)
    ID              reduce using rule 51 (command -> IF LPAREN exp_logic RPAREN bloc else .)
    RCURLYBRACE     reduce using rule 51 (command -> IF LPAREN exp_logic RPAREN bloc else .)
    SEMICOLON       reduce using rule 51 (command -> IF LPAREN exp_logic RPAREN bloc else .)


state 219

    (58) else -> ELSE . bloc
    (44) bloc -> . bloc_com
    (45) bloc -> . command SEMICOLON
    (43) bloc_com -> . LCURLYBRACE com_list RCURLYBRACE
    (48) command -> . atrib SEMICOLON
    (49) command -> . WHILE LPAREN exp_logic RPAREN bloc
    (50) command -> . DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON
    (51) command -> . IF LPAREN exp_logic RPAREN bloc else
    (52) command -> . FOR LPAREN for_exp RPAREN bloc
    (53) command -> . SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE
    (54) command -> . BREAK SEMICOLON
    (55) command -> . CONTINUE SEMICOLON
    (56) command -> . RETURN exp SEMICOLON
    (57) atrib -> . ID name ASSIGNMENT exp

    LCURLYBRACE     shift and go to state 140
    WHILE           shift and go to state 156
    DO              shift and go to state 157
    IF              shift and go to state 158
    FOR             shift and go to state 159
    SWITCH          shift and go to state 160
    BREAK           shift and go to state 162
    CONTINUE        shift and go to state 163
    RETURN          shift and go to state 164
    ID              shift and go to state 161

    bloc                           shift and go to state 225
    bloc_com                       shift and go to state 174
    command                        shift and go to state 175
    atrib                          shift and go to state 155

state 220

    (59) else -> empty .

    WHILE           reduce using rule 59 (else -> empty .)
    DO              reduce using rule 59 (else -> empty .)
    IF              reduce using rule 59 (else -> empty .)
    FOR             reduce using rule 59 (else -> empty .)
    SWITCH          reduce using rule 59 (else -> empty .)
    BREAK           reduce using rule 59 (else -> empty .)
    CONTINUE        reduce using rule 59 (else -> empty .)
    RETURN          reduce using rule 59 (else -> empty .)
    ID              reduce using rule 59 (else -> empty .)
    RCURLYBRACE     reduce using rule 59 (else -> empty .)
    SEMICOLON       reduce using rule 59 (else -> empty .)


state 221

    (60) for_exp -> atrib_decl SEMICOLON exp_logic SEMICOLON . atrib
    (57) atrib -> . ID name ASSIGNMENT exp

    ID              shift and go to state 161

    atrib                          shift and go to state 226

state 222

    (61) for_exp -> type ID COLON ID . name
    (95) name -> . field
    (96) name -> . array_size name_non_empty
    (97) name -> . LPAREN params RPAREN name_non_empty
    (98) name -> . empty
    (102) field -> . DOT ID name_non_empty
    (103) field -> . empty
    (104) array_size -> . LSBRACKET exp_math RSBRACKET array_size_non_empty
    (105) array_size -> . empty
    (113) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LSBRACKET resolved as shift
    LPAREN          shift and go to state 95
    DOT             shift and go to state 97
    LSBRACKET       shift and go to state 98
    RPAREN          reduce using rule 113 (empty -> .)

  ! LPAREN          [ reduce using rule 113 (empty -> .) ]
  ! DOT             [ reduce using rule 113 (empty -> .) ]
  ! LSBRACKET       [ reduce using rule 113 (empty -> .) ]

    name                           shift and go to state 227
    field                          shift and go to state 93
    array_size                     shift and go to state 94
    empty                          shift and go to state 96

state 223

    (53) command -> SWITCH LPAREN ID name RPAREN LCURLYBRACE . switch_case RCURLYBRACE
    (62) switch_case -> . CASE const COLON bloc switch_case
    (63) switch_case -> . DEFAULT bloc

    CASE            shift and go to state 229
    DEFAULT         shift and go to state 230

    switch_case                    shift and go to state 228

state 224

    (50) command -> DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON .

    WHILE           reduce using rule 50 (command -> DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON .)
    DO              reduce using rule 50 (command -> DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON .)
    IF              reduce using rule 50 (command -> DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON .)
    FOR             reduce using rule 50 (command -> DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON .)
    SWITCH          reduce using rule 50 (command -> DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON .)
    BREAK           reduce using rule 50 (command -> DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 50 (command -> DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON .)
    RETURN          reduce using rule 50 (command -> DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON .)
    ID              reduce using rule 50 (command -> DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON .)
    RCURLYBRACE     reduce using rule 50 (command -> DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 50 (command -> DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON .)


state 225

    (58) else -> ELSE bloc .

    WHILE           reduce using rule 58 (else -> ELSE bloc .)
    DO              reduce using rule 58 (else -> ELSE bloc .)
    IF              reduce using rule 58 (else -> ELSE bloc .)
    FOR             reduce using rule 58 (else -> ELSE bloc .)
    SWITCH          reduce using rule 58 (else -> ELSE bloc .)
    BREAK           reduce using rule 58 (else -> ELSE bloc .)
    CONTINUE        reduce using rule 58 (else -> ELSE bloc .)
    RETURN          reduce using rule 58 (else -> ELSE bloc .)
    ID              reduce using rule 58 (else -> ELSE bloc .)
    RCURLYBRACE     reduce using rule 58 (else -> ELSE bloc .)
    SEMICOLON       reduce using rule 58 (else -> ELSE bloc .)


state 226

    (60) for_exp -> atrib_decl SEMICOLON exp_logic SEMICOLON atrib .

    RPAREN          reduce using rule 60 (for_exp -> atrib_decl SEMICOLON exp_logic SEMICOLON atrib .)


state 227

    (61) for_exp -> type ID COLON ID name .

    RPAREN          reduce using rule 61 (for_exp -> type ID COLON ID name .)


state 228

    (53) command -> SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case . RCURLYBRACE

    RCURLYBRACE     shift and go to state 231


state 229

    (62) switch_case -> CASE . const COLON bloc switch_case
    (108) const -> . NUMBER
    (109) const -> . STRING
    (110) const -> . CHARACTER
    (111) const -> . TRUE
    (112) const -> . FALSE

    NUMBER          shift and go to state 74
    STRING          shift and go to state 75
    CHARACTER       shift and go to state 76
    TRUE            shift and go to state 77
    FALSE           shift and go to state 78

    const                          shift and go to state 232

state 230

    (63) switch_case -> DEFAULT . bloc
    (44) bloc -> . bloc_com
    (45) bloc -> . command SEMICOLON
    (43) bloc_com -> . LCURLYBRACE com_list RCURLYBRACE
    (48) command -> . atrib SEMICOLON
    (49) command -> . WHILE LPAREN exp_logic RPAREN bloc
    (50) command -> . DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON
    (51) command -> . IF LPAREN exp_logic RPAREN bloc else
    (52) command -> . FOR LPAREN for_exp RPAREN bloc
    (53) command -> . SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE
    (54) command -> . BREAK SEMICOLON
    (55) command -> . CONTINUE SEMICOLON
    (56) command -> . RETURN exp SEMICOLON
    (57) atrib -> . ID name ASSIGNMENT exp

    LCURLYBRACE     shift and go to state 140
    WHILE           shift and go to state 156
    DO              shift and go to state 157
    IF              shift and go to state 158
    FOR             shift and go to state 159
    SWITCH          shift and go to state 160
    BREAK           shift and go to state 162
    CONTINUE        shift and go to state 163
    RETURN          shift and go to state 164
    ID              shift and go to state 161

    bloc                           shift and go to state 233
    bloc_com                       shift and go to state 174
    command                        shift and go to state 175
    atrib                          shift and go to state 155

state 231

    (53) command -> SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE .

    WHILE           reduce using rule 53 (command -> SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE .)
    DO              reduce using rule 53 (command -> SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE .)
    IF              reduce using rule 53 (command -> SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE .)
    FOR             reduce using rule 53 (command -> SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE .)
    SWITCH          reduce using rule 53 (command -> SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE .)
    BREAK           reduce using rule 53 (command -> SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE .)
    CONTINUE        reduce using rule 53 (command -> SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE .)
    RETURN          reduce using rule 53 (command -> SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE .)
    ID              reduce using rule 53 (command -> SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE .)
    RCURLYBRACE     reduce using rule 53 (command -> SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE .)
    SEMICOLON       reduce using rule 53 (command -> SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE .)


state 232

    (62) switch_case -> CASE const . COLON bloc switch_case

    COLON           shift and go to state 234


state 233

    (63) switch_case -> DEFAULT bloc .

    RCURLYBRACE     reduce using rule 63 (switch_case -> DEFAULT bloc .)


state 234

    (62) switch_case -> CASE const COLON . bloc switch_case
    (44) bloc -> . bloc_com
    (45) bloc -> . command SEMICOLON
    (43) bloc_com -> . LCURLYBRACE com_list RCURLYBRACE
    (48) command -> . atrib SEMICOLON
    (49) command -> . WHILE LPAREN exp_logic RPAREN bloc
    (50) command -> . DO bloc WHILE LPAREN exp_logic RPAREN SEMICOLON
    (51) command -> . IF LPAREN exp_logic RPAREN bloc else
    (52) command -> . FOR LPAREN for_exp RPAREN bloc
    (53) command -> . SWITCH LPAREN ID name RPAREN LCURLYBRACE switch_case RCURLYBRACE
    (54) command -> . BREAK SEMICOLON
    (55) command -> . CONTINUE SEMICOLON
    (56) command -> . RETURN exp SEMICOLON
    (57) atrib -> . ID name ASSIGNMENT exp

    LCURLYBRACE     shift and go to state 140
    WHILE           shift and go to state 156
    DO              shift and go to state 157
    IF              shift and go to state 158
    FOR             shift and go to state 159
    SWITCH          shift and go to state 160
    BREAK           shift and go to state 162
    CONTINUE        shift and go to state 163
    RETURN          shift and go to state 164
    ID              shift and go to state 161

    bloc                           shift and go to state 235
    bloc_com                       shift and go to state 174
    command                        shift and go to state 175
    atrib                          shift and go to state 155

state 235

    (62) switch_case -> CASE const COLON bloc . switch_case
    (62) switch_case -> . CASE const COLON bloc switch_case
    (63) switch_case -> . DEFAULT bloc

    CASE            shift and go to state 229
    DEFAULT         shift and go to state 230

    switch_case                    shift and go to state 236

state 236

    (62) switch_case -> CASE const COLON bloc switch_case .

    RCURLYBRACE     reduce using rule 62 (switch_case -> CASE const COLON bloc switch_case .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 50 resolved as shift
WARNING: shift/reduce conflict for MORETHAN in state 62 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 62 resolved as shift
WARNING: shift/reduce conflict for MOREOREQUALTHAN in state 62 resolved as shift
WARNING: shift/reduce conflict for LESSOREQUALTHAN in state 62 resolved as shift
WARNING: shift/reduce conflict for DOUBLEEQUALS in state 62 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 62 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 65 resolved as shift
WARNING: shift/reduce conflict for DOT in state 65 resolved as shift
WARNING: shift/reduce conflict for LSBRACKET in state 65 resolved as shift
WARNING: shift/reduce conflict for DOT in state 71 resolved as shift
WARNING: shift/reduce conflict for ID in state 84 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 91 resolved as shift
WARNING: shift/reduce conflict for DOT in state 91 resolved as shift
WARNING: shift/reduce conflict for LSBRACKET in state 91 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 94 resolved as shift
WARNING: shift/reduce conflict for DOT in state 94 resolved as shift
WARNING: shift/reduce conflict for LSBRACKET in state 94 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 99 resolved as shift
WARNING: shift/reduce conflict for DOT in state 99 resolved as shift
WARNING: shift/reduce conflict for LSBRACKET in state 99 resolved as shift
WARNING: shift/reduce conflict for MORETHAN in state 114 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 114 resolved as shift
WARNING: shift/reduce conflict for MOREOREQUALTHAN in state 114 resolved as shift
WARNING: shift/reduce conflict for LESSOREQUALTHAN in state 114 resolved as shift
WARNING: shift/reduce conflict for DOUBLEEQUALS in state 114 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 114 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 115 resolved as shift
WARNING: shift/reduce conflict for DOT in state 115 resolved as shift
WARNING: shift/reduce conflict for LSBRACKET in state 115 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 123 resolved as shift
WARNING: shift/reduce conflict for DOT in state 123 resolved as shift
WARNING: shift/reduce conflict for LSBRACKET in state 123 resolved as shift
WARNING: shift/reduce conflict for MORETHAN in state 125 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 125 resolved as shift
WARNING: shift/reduce conflict for MOREOREQUALTHAN in state 125 resolved as shift
WARNING: shift/reduce conflict for LESSOREQUALTHAN in state 125 resolved as shift
WARNING: shift/reduce conflict for DOUBLEEQUALS in state 125 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 125 resolved as shift
WARNING: shift/reduce conflict for ID in state 129 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 132 resolved as shift
WARNING: shift/reduce conflict for DOT in state 132 resolved as shift
WARNING: shift/reduce conflict for LSBRACKET in state 132 resolved as shift
WARNING: shift/reduce conflict for LSBRACKET in state 137 resolved as shift
WARNING: shift/reduce conflict for ID in state 138 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 145 resolved as shift
WARNING: shift/reduce conflict for DOT in state 145 resolved as shift
WARNING: shift/reduce conflict for LSBRACKET in state 145 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 161 resolved as shift
WARNING: shift/reduce conflict for DOT in state 161 resolved as shift
WARNING: shift/reduce conflict for LSBRACKET in state 161 resolved as shift
WARNING: shift/reduce conflict for LSBRACKET in state 183 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 194 resolved as shift
WARNING: shift/reduce conflict for DOT in state 194 resolved as shift
WARNING: shift/reduce conflict for LSBRACKET in state 194 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 199 resolved as shift
WARNING: shift/reduce conflict for DOT in state 199 resolved as shift
WARNING: shift/reduce conflict for LSBRACKET in state 199 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 200 resolved as shift
WARNING: shift/reduce conflict for DOT in state 200 resolved as shift
WARNING: shift/reduce conflict for LSBRACKET in state 200 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 222 resolved as shift
WARNING: shift/reduce conflict for DOT in state 222 resolved as shift
WARNING: shift/reduce conflict for LSBRACKET in state 222 resolved as shift
WARNING: reduce/reduce conflict in state 62 resolved using rule (exp -> exp_math)
WARNING: rejected rule (exp_logic_tail -> exp_math) in state 62
WARNING: reduce/reduce conflict in state 96 resolved using rule (name -> empty)
WARNING: rejected rule (field -> empty) in state 96
WARNING: reduce/reduce conflict in state 96 resolved using rule (name -> empty)
WARNING: rejected rule (array_size -> empty) in state 96
WARNING: reduce/reduce conflict in state 119 resolved using rule (field -> empty)
WARNING: rejected rule (array_size -> empty) in state 119
WARNING: Rule (array_size -> empty) is never reduced
